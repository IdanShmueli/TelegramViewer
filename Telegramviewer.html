<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Chat Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ======= Basic Styles ======= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        :root {
            --main-bg-color: #f2f2f2;
            --header-bg-color: #5682a3;
            --header-button-color: #6e9cc6;
            --header-button-hover: #4e7ca3;
            --chat-body-bg: #e6ebbe; /* רקע בהיר יותר בסגנון טלגרם/וואטסאפ */
            --chat-overlay-bg: rgba(230, 235, 190, 0.85);
            --message-out-bg: #e1ffc7; /* ירוק בהיר להודעות יוצאות (כמו בטלגרם/וואטסאפ) */
            --message-in-bg: white;
            --date-header-bg: rgba(225, 245, 254, 0.92);
            --service-message-bg: rgba(204, 224, 245, 0.92);
            --attachment-bg: rgba(0, 0, 0, 0.05);
            --link-color: #168acd;
            --text-color: #000000;
            --text-secondary-color: #70777b;
            --border-color: #e3e6e8;
            --reaction-bg: #e8f5fc;
            --reaction-color: #168acd;
            --shadow-color: rgba(0, 0, 0, 0.13);
        }

        .dark-mode {
            --main-bg-color: #0e1621; /* רקע כהה יותר בסגנון טלגרם */
            --header-bg-color: #232e3c;
            --header-button-color: #424242;
            --header-button-hover: #505050;
            --chat-body-bg: #0f1a27; /* רקע כהה בסגנון טלגרם */
            --chat-overlay-bg: rgba(15, 26, 39, 0.85);
            --message-out-bg: #2b5278; /* כחול-כהה להודעות יוצאות במצב כהה */
            --message-in-bg: #182533; /* אפור כהה להודעות נכנסות במצב כהה */
            --date-header-bg: rgba(70, 90, 110, 0.92);
            --service-message-bg: rgba(70, 90, 110, 0.92);
            --attachment-bg: rgba(255, 255, 255, 0.05);
            --link-color: #64b5f6;
            --text-color: #ffffff;
            --text-secondary-color: #aaaaaa;
            --border-color: #444444;
            --reaction-bg: #303f4f;
            --reaction-color: #8ab4f8;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
            background-color: var(--main-bg-color);
            direction: rtl;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: var(--text-color);
            transition: background-color 0.3s ease;
        }

        /* ======= Toolbar ======= */
        .toolbar {
            background-color: var(--header-bg-color);
            padding: 15px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            z-index: 100;
            box-shadow: 0 2px 5px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .toolbar button {
            background-color: var(--header-button-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .toolbar button:hover {
            background-color: var(--header-button-hover);
        }

        .toolbar input[type="file"] {
            display: none;
        }

        /* ======= Container ======= */
        .container {
            flex: 1;
            display: flex;
            justify-content: center;
            padding: 20px;
            overflow: auto;
        }

        #chat-container {
            width: 100%;
            max-width: 650px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--message-in-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px var(--shadow-color);
            transition: background-color 0.3s ease;

        }

        /* ======= Chat Header ======= */
        .chat-header {
            background-color: var(--header-bg-color);
            color: white;
            padding: 15px;
            display: flex;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .avatar {
            width: 45px;
            height: 45px;
            background-color: var(--header-button-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 15px;
            color: white;
            font-weight: bold;
            font-size: 20px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .chat-info h2 {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .chat-info p {
            font-size: 13px;
            opacity: 0.8;
        }

        /* ======= Chat Body ======= */
        .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: var(--chat-body-bg);
            position: relative;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-color 0.3s ease;
            background-image: url('https://i.pinimg.com/originals/59/21/62/592162726a4cf64a5e06f749ceb6f1e9.jpg') / רקע ברירת מחדל בסגנון וואטסאפ לייט מוד */
        }

        .chat-body.has-background::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--chat-overlay-bg);
            z-index: 0;
            transition: background-color 0.3s ease;
        }

        /* ======= No Chat ======= */
        .no-chat {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary-color);
            padding: 20px;
            text-align: center;
        }

        .no-chat i {
            font-size: 60px;
            color: var(--header-bg-color);
            margin-bottom: 20px;
        }

        .no-chat p {
            font-size: 16px;
            margin-bottom: 10px;
        }

        /* ======= Date Header ======= */
        .date-header {
            text-align: center;
            margin: 15px 0;
            position: relative;
            z-index: 1;
        }

        .date-header span {
            background-color: var(--date-header-bg);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary-color);
            box-shadow: 0 1px 0.5px var(--shadow-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

/* ======= Messages ======= */
.message {
    display: flex;
    margin-bottom: 8px;
    position: relative;
    z-index: 1;
}

.message.out {
    justify-content: flex-end;
}

.message-bubble {
    max-width: 65%;
    padding: 8px 10px;
    border-radius: 12px; /* יותר עגול כמו בטלגרם */
    position: relative;
    word-wrap: break-word;
    line-height: 1.4;
    font-size: 14px;
    box-shadow: 0 1px 0.5px var(--shadow-color);
    transition: background-color 0.3s ease;
}

.out .message-bubble {
    background-color: var(--message-in-bg);
    margin-left: 50px;
    border-top-right-radius: 2px; /* פינה ימנית עליונה פחות עגולה */
}

.in .message-bubble {
    background-color: var(--message-out-bg);
    margin-right: 50px;
    border-top-left-radius: 2px; /* פינה שמאלית עליונה פחות עגולה */
}

.sender {
    font-size: 12.5px;
    font-weight: 500;
    margin-bottom: 4px;
}

.message-content {
    margin-bottom: 4px;
}

.message-time {
    font-size: 11px;
    color: var(--text-secondary-color);
    text-align: left;
    float: right;
    margin-top: 2px;
    opacity: 0.7; /* קצת יותר שקוף כמו בטלגרם */
}

/* ======= Forwarded Message ======= */
.message-note {
    font-size: 11px;
    font-style: italic;
    color: var(--text-secondary-color);
    margin-top: 2px;
    margin-bottom: 4px;
    display: flex;
    align-items: center;
}

.message-note i {
    margin-left: 4px;
    font-size: 10px;
}

.message-forwarded {
    color: var(--link-color);
    padding-bottom: 4px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    margin-bottom: 6px;
}

/* ======= Chat Body Background ======= */
.chat-body {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    background-color: var(--chat-body-bg);
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    transition: background-color 0.3s ease;
    background-image: url('https://i.pinimg.com/originals/59/21/62/592162726a4cf64a5e06f749ceb6f1e9.jpg'); / רקע ברירת מחדל בסגנון וואטסאפ לייט מוד */

}

.dark-mode .chat-body {
    background-image: url('https://i.pinimg.com/736x/d2/bf/d3/d2bfd3ea45910c01255ae022181148c4.jpg')
}

.chat-body.has-background::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--chat-overlay-bg);
    z-index: 0;
    transition: background-color 0.3s ease;
}
        /* ======= Attachments ======= */
        .attachment {
            margin-bottom: 5px;
        }

        .attachment img, .sticker img {
            max-width: 100%;
            border-radius: 6px;
            cursor: pointer;
        }

        .attachment-image {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .attachment-image:hover {
            transform: scale(1.02);
        }

        .sticker {
            margin-bottom: 5px;
        }

        .sticker img {
            max-width: 150px;
            max-height: 150px;
            cursor: pointer;
        }

        .attachment-file {
            display: flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .attachment-file i {
            font-size: 24px;
            margin-left: 10px;
            color: var(--text-secondary-color);
        }

        .attachment-file span {
            font-size: 13px;
        }

        .audio-attachment {
            margin-bottom: 5px;
        }

        .audio-attachment audio {
            width: 100%;
            height: 36px;
        }

        /* ======= Image Modal ======= */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 30px;
            cursor: pointer;
        }

        /* ======= Loading and Progress ======= */
        .loader {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
        }

        .loader i {
            font-size: 40px;
            margin-bottom: 10px;
        }

        /* ======= Status Message ======= */
        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 3000;
            display: none;
        }

        #status.success {
            background-color: #28a745;
        }

        #status.error {
            background-color: #dc3545;
        }

        /* Ensure chat content appears above background */
        #messages-container {
            position: relative;
            z-index: 1;
        }

        /* ======= New settings for Profile and Background ======= */
        .settings-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .settings-container {
            background-color: var(--message-in-bg);
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            transition: background-color 0.3s ease;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .settings-title {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-color);
        }

        .settings-close {
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary-color);
        }

        .settings-section {
            margin-bottom: 15px;
        }

        .settings-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: var(--link-color);
        }

        .settings-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .settings-preview {
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-preview {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: var(--header-button-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 36px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .profile-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .background-preview {
            width: 200px;
            height: 150px;
            border-radius: 8px;
            border: 2px dashed #ddd;
            background-color: var(--chat-body-bg);
            background-size: cover;
            background-position: center;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        .file-input-wrapper {
            margin-top: 10px;
        }

        .custom-file-input {
            background-color: var(--attachment-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            font-size: 14px;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .custom-file-input:hover {
            background-color: var(--header-button-hover);
            color: white;
        }

        /* Style for remove image button */
        .remove-image-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .remove-image-btn:hover {
            background-color: #c82333;
        }

        /* ======= New styles for message notes visualization ======= */
        .message-note {
            font-size: 11px;
            font-style: italic;
            color: var(--text-secondary-color);
            margin-top: 2px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
        }

        .message-note i {
            margin-left: 4px;
            font-size: 10px;
        }

        .message-edited {
            color: var(--link-color);
        }

        .message-deleted {
            color: #dc3545;
        }

        .message-forwarded {
            color: var(--text-secondary-color);
        }

        /* ======= New styles for participant management ======= */
        .participants-section {
            margin-bottom: 20px;
            max-height: 250px;
            overflow-y: auto;
        }

        .participant-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--header-button-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin-left: 10px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .participant-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-weight: 500;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            color: var(--text-color);
        }

        .participant-color-preview {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            border: 1px solid var(--border-color);
        }

        .participant-actions {
            display: flex;
            align-items: center;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }

        .color-picker-label {
            font-size: 12px;
            margin-left: 8px;
            color: var(--text-secondary-color);
        }

        input[type="color"] {
            width: 25px;
            height: 25px;
            border: none;
            cursor: pointer;
        }

        .participant-upload {
            background-color: var(--attachment-bg);
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .participant-upload:hover {
            background-color: var(--header-button-hover);
            color: white;
        }

        .participant-upload[disabled] {
            background-color: #28a745;
            color: white;
            opacity: 0.7;
        }

        .no-participants {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary-color);
            font-style: italic;
        }

        /* ======= Unique Telegram styles ======= */
        .service-message {
            text-align: center;
            margin: 10px 0;
            position: relative;
            z-index: 1;
        }

        .service-message span {
            background-color: var(--service-message-bg);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary-color);
            box-shadow: 0 1px 0.5px var(--shadow-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .sticker {
            max-width: 150px;
            max-height: 150px;
            border-radius: 0;
        }

        .reply-to {
            margin-bottom: 5px;
            padding: 5px 8px;
            border-right: 3px solid var(--link-color);
            background-color: var(--attachment-bg);
            border-radius: 4px;
            font-size: 12px;
            color: var(--text-secondary-color);
            transition: background-color 0.3s ease;
        }

        .reply-to .reply-sender {
            font-weight: bold;
            color: var(--link-color);
        }

        .reply-to .reply-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .message-views {
            margin-right: 8px;
            font-size: 11px;
            color: var(--text-secondary-color);
        }

        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .reaction {
            display: inline-flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            transition: background-color 0.3s ease;
        }

        .reaction .emoji {
            margin-left: 3px;
        }

        .reaction .count {
            font-size: 11px;
            color: var(--text-secondary-color);
        }

        .poll-container {
            margin-top: 5px;
        }

        .poll-question {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .poll-option {
            display: flex;
            margin-bottom: 4px;
        }

        .poll-option-text {
            flex: 1;
        }

        .poll-option-votes {
            font-size: 12px;
            color: var(--text-secondary-color);
            margin-right: 5px;
        }

        .poll-option-bar {
            height: 4px;
            background-color: var(--border-color);
            margin-top: 4px;
            position: relative;
            transition: background-color 0.3s ease;
        }

        .poll-option-progress {
            height: 100%;
            background-color: var(--link-color);
            position: absolute;
            top: 0;
            right: 0;
            transition: background-color 0.3s ease;
        }

        .location-preview {
            width: 100%;
            height: 150px;
            background-color: var(--attachment-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .location-preview i {
            font-size: 24px;
            color: var(--link-color);
            margin-left: 10px;
        }

        .video-note {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .video-note video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .voice-message {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .voice-message i {
            font-size: 18px;
            color: var(--link-color);
            margin-left: 10px;
        }

        .voice-message audio {
            flex: 1;
            height: 32px;
        }

        .voice-message-duration {
            font-size: 12px;
            color: var(--text-secondary-color);
            margin-right: 10px;
        }

        /* Style for Telegram reactions */
        .reactions {
            margin-top: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .reaction {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            background-color: var(--reaction-bg);
            color: var(--reaction-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .reaction .emoji {
            margin-left: 3px;
        }

        .reaction .count {
            font-size: 11px;
            margin-right: 3px;
        }

        /* Video frame */
        .video-container {
            position: relative;
            margin-bottom: 5px;
            border-radius: 6px;
            overflow: hidden;
        }

        .video-container video {
            width: 100%;
            max-height: 300px;
            object-fit: contain;
        }

        .video-duration {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 11px;
        }

        /* Style for attached file */
        .document-container {
            display: flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .document-icon {
            font-size: 24px;
            margin-left: 10px;
            color: var(--link-color);
        }

        .document-info {
            flex: 1;
        }

        .document-title {
            font-weight: bold;
            margin-bottom: 2px;
            color: var(--text-color);
        }

        .document-size {
            font-size: 11px;
            color: var(--text-secondary-color);
        }

        /* Style for HEIC file display */
        .heic-info {
            font-size: 12px;
            color: var(--text-secondary-color);
            margin-top: 5px;
            font-style: italic;
        }

        /* Style for video thumbnails */
        .video-thumbnail {
            position: relative;
            max-width: 100%;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .video-play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .video-info {
            font-size: 12px;
            color: var(--text-secondary-color);
            margin-top: 5px;
            text-align: center;
        }

        /* Style for animated stickers */
        .sticker-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--attachment-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .sticker-emoji {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .sticker-info {
            font-size: 12px;
            color: var(--text-secondary-color);
        }

        /* Support for animated stickers */
        .lottie-container {
            width: 150px;
            height: 150px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker-animation {
            width: 150px;
            height: 150px;
            margin: 0 auto;
            margin-bottom: 5px;
        }

        /* Style for contact */
        .contact-preview {
            margin-bottom: 5px;
        }

        .contact-info {
            display: flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 10px;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .contact-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--link-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-left: 12px;
        }

        .contact-details {
            flex: 1;
        }

        .contact-name {
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--text-color);
        }

        .contact-phone {
            font-size: 13px;
            color: var(--text-secondary-color);
            direction: ltr;
            text-align: right;
        }

        /* Style for location */
        .location-box {
            display: flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .location-box i {
            font-size: 24px;
            color: #e74c3c;
            margin-left: 15px;
        }

        .location-info {
            flex: 1;
            color: var(--text-color);
        }

        .location-coordinates {
            direction: ltr;
            font-family: monospace;
            margin: 5px 0;
            color: var(--text-secondary-color);
        }

        .location-link {
            display: inline-block;
            padding: 5px 10px;
            background-color: var(--link-color);
            color: white;
            border-radius: 4px;
            text-decoration: none;
            margin-top: 5px;
            font-size: 12px;
            transition: background-color 0.3s ease;
        }

        .location-link:hover {
            background-color: var(--header-button-hover);
        }

        /* Style for round video messages */
        .video-note-thumbnail {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            overflow: hidden;
            margin-bottom: 5px;
            position: relative;
        }

        /* Style for preview */
        .preview-note {
            font-size: 11px;
            color: var(--text-secondary-color);
            font-style: italic;
            margin-top: 5px;
            text-align: center;
        }

        /* Style for download options */
        .download-link {
            display: inline-block;
            padding: 5px 10px;
            margin-top: 8px;
            background-color: var(--link-color);
            color: white;
            border-radius: 4px;
            text-decoration: none;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .download-link:hover {
            background-color: var(--header-button-hover);
            text-decoration: none;
            color: white;
        }

        .download-link i {
            margin-left: 5px;
        }

        /* Style for downloadable files */
        .file-download-container {
            display: flex;
            align-items: center;
            background-color: var(--attachment-bg);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .file-icon {
            font-size: 24px;
            margin-left: 15px;
            color: var(--link-color);
        }

        .file-info {
            flex: 1;
            color: var(--text-color);
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .file-size {
            font-size: 12px;
            color: var(--text-secondary-color);
        }

        .download-button {
            background-color: var(--link-color);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            transition: background-color 0.2s;
        }

        .download-button:hover {
            background-color: var(--header-button-hover);
            color: white;
        }

        /* Style for HEIC display */
        .heic-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 5px;
        }

        /* Loading element */
        .loading-media {
            padding: 20px;
            text-align: center;
            background-color: var(--attachment-bg);
            border-radius: 8px;
            margin-bottom: 5px;
            color: var(--text-secondary-color);
            font-style: italic;
            transition: background-color 0.3s ease;
        }

        /* Video */
        .video-download {
            text-align: center;
            margin-top: 8px;
        }

        /* Hide long Data URLs from console */
        .data-url {
            display: none;
        }

        /* New styles for special media files */
        .video-fallback {
            background-color: var(--attachment-bg);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 5px;
            transition: background-color 0.3s ease;
        }

        .video-fallback-icon {
            font-size: 36px;
            color: var(--link-color);
            margin-bottom: 10px;
        }

        .video-player {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        /* Support for animated stickers */
        .sticker-animation-container {
            width: 150px;
            height: 150px;
            margin: 0 auto;
            margin-bottom: 5px;
            position: relative;
        }

        /* Style for animated sticker play button */
        .sticker-play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(86, 130, 163, 0.7);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            z-index: 5;
        }

        .sticker-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Dark mode toggle style */
        .mode-toggle {
            background-color: transparent;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            margin-left: 15px;
            transition: background-color 0.2s;
        }

        .mode-toggle:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Toggle button in toolbar */
        #mode-toggle-btn {
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <input type="file" id="zip-file" accept=".zip">
        <button id="upload-zip-btn">
            <i class="fas fa-file-zipper"></i>
            העלאת ZIP מלא
        </button>
        
        <input type="file" id="json-file" accept=".json">
        <button id="upload-json-btn">
            <i class="fas fa-file-code"></i>
            העלאת JSON בלבד
        </button>
        
        <button id="settings-btn">
            <i class="fas fa-cog"></i>
            הגדרות מראה
        </button>
        
        <button id="participants-btn">
            <i class="fas fa-users"></i>
            משתתפים
        </button>
        
        <button id="export-html-btn">
            <i class="fas fa-file-code"></i>
            ייצוא ל-HTML
        </button>
        
        <button id="clear-btn">
            <i class="fas fa-trash"></i>
            ניקוי הכל
        </button>
        
        <button id="reverse-sides-btn" title="החלף צדדי שולח ומקבל">
            <i class="fas fa-exchange-alt"></i>
            החלף צדדים
        </button>
        
        <button id="mode-toggle-btn">
            <i class="fas fa-moon"></i>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <div id="chat-container">
            <div class="no-chat">
                <i class="fas fa-paper-plane"></i>
                <p>אין שיחה להצגה</p>
                <p>העלה קובץ ZIP של שיחת טלגרם כדי להתחיל</p>
            </div>
        </div>
    </div>

    <!-- Modal for images -->
    <div id="image-modal" class="modal">
        <span class="modal-close">&times;</span>
        <img class="modal-content" id="modal-image">
    </div>

    <!-- Loading screen -->
    <div id="loader" class="loader">
        <i class="fas fa-spinner fa-spin"></i>
        <div id="loader-text">טוען...</div>
    </div>

    <!-- Status message -->
    <div id="status"></div>

    <!-- Settings panel -->
    <div id="settings-panel" class="settings-panel">
        <div class="settings-container">
            <div class="settings-header">
                <div class="settings-title">הגדרות מראה</div>
                <div class="settings-close">&times;</div>
            </div>
            <div class="settings-section">
                <h3>תמונת פרופיל</h3>
                <div class="settings-preview">
                    <div class="profile-preview" id="profile-preview">
                        <span id="profile-initial"></span>
                    </div>
                </div>
                <div class="file-input-wrapper">
                    <label class="custom-file-input">
                        בחר תמונה
                        <input type="file" id="profile-image-input" accept="image/*" style="display: none;">
                    </label>
                    <button id="remove-profile-image" class="remove-image-btn" style="display: none;">
                        <i class="fas fa-trash"></i> הסר תמונה
                    </button>
                </div>
            </div>
            <div class="settings-section">
                <h3>תמונת רקע לשיחה</h3>
                <div class="background-preview" id="background-preview"></div>
                <div class="file-input-wrapper">
                    <label class="custom-file-input">
                        בחר תמונת רקע
                        <input type="file" id="background-image-input" accept="image/*" style="display: none;">
                    </label>
                    <button id="remove-background-image" class="remove-image-btn" style="display: none;">
                        <i class="fas fa-trash"></i> הסר רקע
                    </button>
                </div>
            </div>
            <div class="settings-actions">
                <button id="close-settings" class="toolbar-button">סגור</button>
            </div>
        </div>
    </div>

    <!-- Participants panel -->
    <div id="participants-panel" class="settings-panel">
        <div class="settings-container">
            <div class="settings-header">
                <div class="settings-title">ניהול משתתפים</div>
                <div class="settings-close participants-close">&times;</div>
            </div>
            <div class="participants-section" id="participants-list">
                <div class="no-participants">
                    <p>אין משתתפים להצגה. העלה קובץ שיחה תחילה.</p>
                </div>
            </div>
            <div class="settings-actions">
                <button id="close-participants" class="toolbar-button">סגור</button>
            </div>
        </div>
    </div>

    <!-- External libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // ===================================================
        // =============== Global Objects ===============
        // ===================================================

        // Media files store
        const mediaStore = new Map();

        // Chat data
        let chatData = {
            name: '',
            type: '', // 'private', 'group' or 'channel'
            messages: [],
            about: ''
        };

        // Profile and background image info
        let appSettings = {
            profileImage: null,
            backgroundImage: null,
            darkMode: false,
            reverseMessageSides: true  // משתנה חדש שקובע אם להפוך את הצדדים של השולח והמקבל
        };

        // Participants info
        let participants = new Map();

        // Current user info
        let currentUser = {
            id: null,
            name: '',
            username: ''
        };

        // Current receiver ID (משתמש שנבחר כמקבל)
        let currentReceiverId = null;

// ===================================================
// ============== Click Event Handling ==============
// ===================================================

    // Button events
    document.getElementById('upload-json-btn').addEventListener('click', () => {
        document.getElementById('json-file').click();
    });

    document.getElementById('upload-zip-btn').addEventListener('click', () => {
        document.getElementById('zip-file').click();
    });

    document.getElementById('settings-btn').addEventListener('click', () => {
        openSettingsPanel();
    });

    document.getElementById('participants-btn').addEventListener('click', () => {
        openParticipantsPanel();
    });

    document.getElementById('export-html-btn').addEventListener('click', () => {
        exportChat('html');
    });

    document.getElementById('clear-btn').addEventListener('click', clearAll);

    // Mode toggle
    document.getElementById('mode-toggle-btn').addEventListener('click', toggleDarkMode);

    // Reverse sides toggle - הוספת אירוע לחיצה חדש
    document.getElementById('reverse-sides-btn').addEventListener('click', toggleMessageSides);

    // File events
    document.getElementById('json-file').addEventListener('change', handleJsonFile);
    document.getElementById('zip-file').addEventListener('change', handleZipFile);

    // Settings events
    document.getElementById('profile-image-input').addEventListener('change', handleProfileImageUpload);
    document.getElementById('background-image-input').addEventListener('change', handleBackgroundImageUpload);
    document.getElementById('remove-profile-image').addEventListener('click', removeProfileImage);
    document.getElementById('remove-background-image').addEventListener('click', removeBackgroundImage);
    document.querySelector('.settings-close').addEventListener('click', closeSettingsPanel);
    document.getElementById('close-settings').addEventListener('click', closeSettingsPanel);

    // Participants panel events
    document.querySelector('.participants-close').addEventListener('click', closeParticipantsPanel);
    document.getElementById('close-participants').addEventListener('click', closeParticipantsPanel);

    // Close image modal
    document.querySelector('.modal-close').addEventListener('click', closeModal);

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeModal();
            closeSettingsPanel();
            closeParticipantsPanel();
        }
    });

    function loadReverseSidesPreference() {
    try {
        const savedReverseSides = localStorage.getItem('telegramViewerReverseSides');
        if (savedReverseSides !== null) {
            appSettings.reverseMessageSides = savedReverseSides === 'true';
        }
    } catch (e) {
        console.log('Could not load reverse sides preference');
    }
}

// Function to initialize the interface and load libraries
function initializeChatViewer() {
    // Load external libraries if needed
    loadExternalLibraries();
    
    // Load dark mode preference
    loadDarkModePreference();
    
    // Load reverse sides preference - הוספת טעינת העדפת הצדדים
    loadReverseSidesPreference();
    
    // Add event for cleaning up links before window close
    window.addEventListener('beforeunload', function() {
        cleanupDownloadLinks();
    });
    
    // Refresh chat view
    if (chatData && chatData.messages && chatData.messages.length > 0) {
        updateChatView();
    }
    
    console.log('Telegram chat viewer initialized successfully');
}

// Run initialization when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeChatViewer();
});
        // ===================================================
        // ============== External File Handling =============
        // ===================================================
        
        // Function to load required libraries
        function loadExternalLibraries() {
            return new Promise((resolve) => {
                let loadCount = 0;
                const requiredLibs = 2; // Number of libraries to load

                // Load Lottie library for TGS stickers
                if (!window.lottie) {
                    const lottieScript = document.createElement('script');
                    lottieScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.9.6/lottie.min.js';
                    lottieScript.onload = () => {
                        console.log('Lottie library loaded successfully');
                        loadCount++;
                        if (loadCount === requiredLibs) resolve();
                    };
                    document.head.appendChild(lottieScript);
                } else {
                    loadCount++;
                }

                // Load pako library for compressed files (needed for TGS stickers)
                if (!window.pako) {
                    const pakoScript = document.createElement('script');
                    pakoScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js';
                    pakoScript.onload = () => {
                        console.log('Pako library loaded successfully');
                        loadCount++;
                        if (loadCount === requiredLibs) resolve();
                    };
                    document.head.appendChild(pakoScript);
                } else {
                    loadCount++;
                }

                // If all libraries are already loaded
                if (loadCount === requiredLibs) {
                    resolve();
                }
            });
        }

        // Function to create downloadable format from media file
        function createDownloadableFile(mediaFile, fileName) {
            if (!mediaFile || !mediaFile.data) return null;
            
            // Create unique ID
            const uniqueId = 'download_' + Math.random().toString(36).substr(2, 9);
            
            // Create blob
            let blob;
            if (typeof mediaFile.data === 'string' && mediaFile.data.startsWith('data:')) {
                // Convert data URL to blob
                const arr = mediaFile.data.split(',');
                const mime = arr[0].match(/:(.*?);/)[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                blob = new Blob([u8arr], { type: mime });
            } else if (mediaFile.data instanceof Blob) {
                // If it's already a blob, use it directly
                blob = mediaFile.data;
            } else {
                // If it's not a known format, try to convert to blob
                try {
                    blob = new Blob([mediaFile.data], { type: mediaFile.type || 'application/octet-stream' });
                } catch (e) {
                    console.error('Error creating blob from media:', e);
                    return null;
                }
            }
            
            // Create URL from blob
            const url = URL.createObjectURL(blob);
            
            // Store link for later cleanup
            if (!window.downloadLinks) window.downloadLinks = {};
            window.downloadLinks[uniqueId] = url;
            
            return {
                id: uniqueId,
                url: url,
                fileName: fileName || mediaFile.name || 'file',
                size: blob.size,
                type: mediaFile.type || blob.type
            };
        }

        // Function to clean up download links
        function cleanupDownloadLinks() {
            if (window.downloadLinks) {
                Object.values(window.downloadLinks).forEach(url => {
                    URL.revokeObjectURL(url);
                });
                window.downloadLinks = {};
            }
        }

        // Function to try rendering TGS sticker as Lottie animation
        async function renderTgsSticker(mediaFile, containerId) {
            if (!mediaFile || !mediaFile.data) return false;
            
            const container = document.getElementById(containerId);
            if (!container) return false;
            
            try {
                // Ensure required libraries are loaded
                await loadExternalLibraries();
                
                if (!window.lottie || !window.pako) {
                    throw new Error("Required libraries not loaded");
                }
                
                // Create temporary download file
                const downloadInfo = createDownloadableFile(mediaFile, mediaFile.name || 'sticker.tgs');
                
                // Create unique animation ID
                const animationId = 'lottie_' + Math.random().toString(36).substr(2, 9);
                
                // Add animation container
                container.innerHTML = `
                    <div class="sticker-animation-container">
                        <div id="${animationId}" class="lottie-container"></div>
                        <div class="sticker-play-button">
                            <i class="fas fa-play"></i>
                        </div>
                    </div>
                    <div style="text-align: center;">
                    </div>
                `;
                
                // Sticker info
                let tgsData;
                
                // Convert data to ArrayBuffer
                if (typeof mediaFile.data === 'string' && mediaFile.data.startsWith('data:')) {
                    // Convert data URL to ArrayBuffer
                    const base64Data = mediaFile.data.split(',')[1];
                    const binaryString = atob(base64Data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    tgsData = bytes.buffer;
                } else if (mediaFile.data instanceof ArrayBuffer) {
                    tgsData = mediaFile.data;
                } else {
                    throw new Error("Unsupported sticker data format");
                }
                
                // Try to open TGS file (which is a compressed JSON file in gzip format)
                const inflatedData = window.pako.inflate(new Uint8Array(tgsData), { to: 'string' });
                const lottieData = JSON.parse(inflatedData);
                
                // Play button
                const playButton = container.querySelector('.sticker-play-button');
                
                // Auto-play the sticker immediately without requiring click
                playButton.style.display = 'none';
                
                // Play the animation
                const animation = window.lottie.loadAnimation({
                    container: document.getElementById(animationId),
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    animationData: lottieData
                });
                
                return true;
            } catch (error) {
                console.error('Error displaying TGS sticker:', error);
                
                // Show thumbnail if available, otherwise show icon
                const thumbnailData = mediaFile.thumbnail_data || 
                    (mediaFile.thumbnail && mediaStore.has(mediaFile.thumbnail) ? 
                        mediaStore.get(mediaFile.thumbnail).data : null);
                
                // Create temporary download file
                const downloadInfo = createDownloadableFile(mediaFile, mediaFile.name || 'sticker.tgs');
                
                container.innerHTML = `
                    <div class="sticker-placeholder">
                        ${thumbnailData ? 
                            `<img src="${thumbnailData}" alt="Sticker thumbnail" class="sticker-thumbnail">` : 
                            `<span class="sticker-emoji">😀</span>`
                        }
                        <div class="sticker-info">Animated sticker</div>
                        <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-link">
                            <i class="fas fa-download"></i> Download sticker
                        </a>
                    </div>
                `;
                return false;
            }
        }

        // Enhanced function for handling MOV video
        function handleMovVideo(mediaFile, containerId) {
            if (!mediaFile || !mediaFile.data) return false;
            
            try {
                const container = document.getElementById(containerId);
                if (!container) return false;
                
                // Create temporary download file
                const downloadInfo = createDownloadableFile(mediaFile, mediaFile.name || 'video.mov');
                
                // Check if there's a thumbnail
                const thumbnailData = mediaFile.thumbnail_data || 
                    (mediaFile.thumbnail && mediaStore.has(mediaFile.thumbnail) ? 
                        mediaStore.get(mediaFile.thumbnail).data : null);
                
                // Try to convert video to MP4 (not always possible in browser)
                // First show video as-is with several possible formats
                container.innerHTML = `
                    <div class="video-player">
                        <video controls autoplay width="100%" poster="${thumbnailData || ''}">
                            <source src="${downloadInfo.url}" type="video/quicktime">
                            <source src="${downloadInfo.url}" type="video/mp4">
                            <source src="${downloadInfo.url}" type="video/x-m4v">
                            <div class="video-fallback">
                                <div class="video-fallback-icon">
                                    <i class="fas fa-video"></i>
                                </div>
                                <p>Browser cannot display this video</p>
                            </div>
                        </video>
                `;
                
                // Check if video loaded successfully
                const videoElement = container.querySelector('video');
                
                videoElement.addEventListener('error', () => {
                    // If there's an error, show thumbnail with download link
                    if (thumbnailData) {
                        container.innerHTML = `
                            <div class="video-thumbnail">
                                <img src="${thumbnailData}" alt="Video thumbnail" class="attachment-image">
                                <div class="video-play-icon"><i class="fas fa-play-circle"></i></div>
                            </div>
                            <div class="video-info">
                                <p>Cannot display this video in browser</p>
                                <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-link">
                                    <i class="fas fa-download"></i> Download video
                                </a>
                            </div>
                        `;
                    } else {
                        // If no thumbnail, just show icon and download link
                        container.innerHTML = `
                            <div class="video-fallback">
                                <div class="video-fallback-icon">
                                    <i class="fas fa-video"></i>
                                </div>
                                <p>Cannot display this video in browser</p>
                                <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-link">
                                    <i class="fas fa-download"></i> Download video
                                </a>
                            </div>
                        `;
                    }
                });
                
                return true;
            } catch (error) {
                console.error('Error handling MOV file:', error);
                return false;
            }
        }

        // Enhanced function for handling any generic file
        function handleGenericFile(mediaFile, containerId) {
            if (!mediaFile || !mediaFile.data) return false;
            
            try {
                const container = document.getElementById(containerId);
                if (!container) return false;
                
                // Create temporary download file
                const downloadInfo = createDownloadableFile(mediaFile, mediaFile.name);
                if (!downloadInfo) {
                    throw new Error("Could not create download link");
                }
                
                // Appropriate icon for file type
                const fileIcon = getFileIcon(mediaFile.name, mediaFile.type);
                const fileSize = formatFileSize(downloadInfo.size);
                const fileExt = getFileExtension(mediaFile.name);
                
                // Function to check if file can be displayed directly
                const canDisplay = canDisplayFile(fileExt, mediaFile.type);
                
                if (canDisplay) {
                    // If file can be displayed directly
                    if (fileExt === 'pdf') {
                        // If it's PDF, use iframe element
                        container.innerHTML = `
                            <div class="file-preview-container">
                                <div class="file-info" style="margin-bottom: 10px;">
                                    <div class="file-download-container">
                                        <div class="file-icon">
                                            <i class="${fileIcon}"></i>
                                        </div>
                                        <div class="file-info">
                                            <div class="file-name">${mediaFile.name || 'File'}</div>
                                            <div class="file-size">${fileSize}</div>
                                        </div>
                                        <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-button">
                                            <i class="fas fa-download"></i>
                                        </a>
                                    </div>
                                </div>
                                <div class="file-preview">
                                    <iframe src="${downloadInfo.url}" width="100%" height="300px" style="border: 1px solid var(--border-color); border-radius: 4px;"></iframe>
                                </div>
                            </div>
                        `;
                    } else if (fileExt === 'txt' || fileExt === 'html' || fileExt === 'css' || fileExt === 'js') {
                        // If it's a text file, try to display content
                        fetch(downloadInfo.url)
                            .then(response => response.text())
                            .then(text => {
                                container.innerHTML = `
                                    <div class="file-preview-container">
                                        <div class="file-info" style="margin-bottom: 10px;">
                                            <div class="file-download-container">
                                                <div class="file-icon">
                                                    <i class="${fileIcon}"></i>
                                                </div>
                                                <div class="file-info">
                                                    <div class="file-name">${mediaFile.name || 'File'}</div>
                                                    <div class="file-size">${fileSize}</div>
                                                </div>
                                                <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-button">
                                                    <i class="fas fa-download"></i>
                                                </a>
                                            </div>
                                        </div>
                                        <div class="file-preview" style="max-height: 200px; overflow: auto; background-color: var(--attachment-bg); padding: 10px; border-radius: 4px; direction: ltr; text-align: left; font-family: monospace; white-space: pre-wrap;">
                                            ${text.substring(0, 1000)}${text.length > 1000 ? '...' : ''}
                                        </div>
                                    </div>
                                `;
                            })
                            .catch(error => {
                                console.error('Error loading text file:', error);
                                // If there's an error, display file info only
                                displayFileInfoOnly();
                            });
                    } else {
                        // Other files that can be displayed directly
                        displayFileInfoOnly();
                    }
                } else {
                    // Cannot display directly, show file info only
                    displayFileInfoOnly();
                }
                
                // Function to display file info only
                function displayFileInfoOnly() {
                    container.innerHTML = `
                        <div class="file-download-container">
                            <div class="file-icon">
                                <i class="${fileIcon}"></i>
                            </div>
                            <div class="file-info">
                                <div class="file-name">${mediaFile.name || 'File'}</div>
                                <div class="file-size">${fileSize}</div>
                            </div>
                            <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-button">
                                <i class="fas fa-download"></i>
                            </a>
                        </div>
                    `;
                }
                
                return true;
            } catch (error) {
                console.error('Error handling file:', error);
                return false;
            }
        }

        // Function to check if file can be displayed directly
        function canDisplayFile(extension, mimeType) {
            if (!extension) return false;
            
            const displayableExtensions = ['pdf', 'txt', 'html', 'css', 'js'];
            return displayableExtensions.includes(extension.toLowerCase());
        }

        // Function to get file extension
        function getFileExtension(filename) {
            if (!filename) return '';
            return filename.split('.').pop().toLowerCase();
        }

        // Handle JSON file
        function handleJsonFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            showLoader('Processing JSON file...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    processTelegramExport(jsonData);
                    updateChatView();
                    showStatusMessage('Chat loaded successfully', 'success');
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    showStatusMessage('Error loading JSON file', 'error');
                }
                hideLoader();
            };
            reader.onerror = function() {
                console.error('Error reading JSON file');
                showStatusMessage('Error reading JSON file', 'error');
                hideLoader();
            };
            reader.readAsText(file);
        }
        
        // Function to save thumbnails
        function saveThumbnails(allFiles, zip) {
            console.log("Saving thumbnails...");
            
            // Find all thumbnail files
            const thumbnailFiles = allFiles.filter(file => 
                file.path.includes('_thumb.') || 
                file.path.includes('thumbnail')
            );
            
            const thumbnailPromises = thumbnailFiles.map(file => {
                return file.entry.async('blob').then(function(blob) {
                    return new Promise(function(resolve) {
                        const fileName = getFileNameFromPath(file.path);
                        const fileType = getFileType(fileName, blob.type);
                        
                        const reader = new FileReader();
                        reader.onload = function() {
                            // Save thumbnail in media store
                            mediaStore.set(file.path, {
                                data: reader.result,
                                type: fileType,
                                name: fileName,
                                path: file.path,
                                is_thumbnail: true
                            });
                            
                            resolve();
                        };
                        reader.readAsDataURL(blob);
                    });
                });
            });
            
            return Promise.all(thumbnailPromises);
        }

        // Handle full ZIP file
        async function handleZipFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            showLoader('Processing ZIP file...');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                const data = e.target.result;
                
                try {
                    const zip = await JSZip.loadAsync(data);
                    let mediaCount = 0;
                    let jsonFound = false;
                    let jsonData = null;
                    
                    // All files in backup
                    const allFiles = [];
                    
                    zip.forEach(function(relativePath, zipEntry) {
                        if (!zipEntry.dir) {
                            allFiles.push({
                                path: relativePath,
                                entry: zipEntry
                            });
                        }
                    });
                    
                    // Find main JSON file
                    const jsonFiles = allFiles.filter(file => file.path.endsWith('result.json'));
                    
                    if (jsonFiles.length === 0) {
                        showStatusMessage('No main JSON file (result.json) found in archive', 'error');
                        hideLoader();
                        return;
                    }
                    
                    // Load JSON file first
                    try {
                        const jsonContent = await jsonFiles[0].entry.async('text');
                        jsonData = JSON.parse(jsonContent);
                        jsonFound = true;
                        processTelegramExport(jsonData);
                        
                        // Process media files
                        console.log('Processing media files...');

                        // Save thumbnails first
                        await saveThumbnails(allFiles, zip);

                        // Problematic files that need special handling
                        const problematicFiles = [
                            "IMG_2435.MOV",
                            "AnimatedSticker.tgs",
                            "IMG_6855.HEIC",
                            "video.mp4"  // round video
                        ];

                        // Special handling for problematic files
                        const specialMediaFiles = allFiles.filter(file => {
                            const fileName = getFileNameFromPath(file.path);
                            return problematicFiles.includes(fileName);
                        });

                        console.log(`Found ${specialMediaFiles.length} problematic files`);

                        // Process problematic files first
                        const specialPromises = specialMediaFiles.map(file => {
                            return file.entry.async('blob').then(function(blob) {
                                return new Promise(function(resolve) {
                                    const fileName = getFileNameFromPath(file.path);
                                    console.log(`Processing problematic file: ${fileName}, size: ${blob.size}, type: ${blob.type}`);
                                    
                                    const reader = new FileReader();
                                    reader.onload = function() {
                                        const fileType = getFileType(fileName, blob.type);
                                        
                                        // Check if there's a thumbnail for this file and save it
                                        const thumbPath = `${file.path}_thumb.jpg`;
                                        const thumbData = mediaStore.get(thumbPath);
                                        
                                        // Save with all possible access paths
                                        const mediaData = {
                                            data: reader.result,
                                            type: fileType,
                                            name: fileName,
                                            path: file.path,
                                            size: blob.size
                                        };
                                        
                                        // Add thumbnail if exists
                                        if (thumbData) {
                                            mediaData.thumbnail_data = thumbData.data;
                                        }
                                        
                                        mediaStore.set(fileName, mediaData);
                                        mediaStore.set(file.path, mediaData);
                                        
                                        // Also save by partial path
                                        const partialPath = file.path.split('/').pop();
                                        if (partialPath !== fileName) {
                                            mediaStore.set(partialPath, mediaData);
                                        }
                                        
                                        console.log(`File ${fileName} saved successfully`);
                                        resolve();
                                    };
                                    reader.readAsDataURL(blob);
                                });
                            }).catch(error => {
                                console.error(`Error processing file ${file.path}:`, error);
                                return Promise.resolve(); // Continue even if error
                            });
                        });

                        await Promise.all(specialPromises);

                        // Now process remaining files
                        const regularMediaFiles = allFiles.filter(file => {
                            // Skip JSON file, thumbnails, and already processed files
                            const fileName = getFileNameFromPath(file.path);
                            return file.path !== jsonFiles[0].path && 
                                   !file.path.includes('_thumb.') && 
                                   !file.path.endsWith('.json') &&
                                   !problematicFiles.includes(fileName);
                        });

                        console.log(`Processing ${regularMediaFiles.length} regular media files...`);

                        // Process remaining files
                        const mediaPromises = regularMediaFiles.map(file => {
                            return file.entry.async('blob').then(function(blob) {
                                return new Promise(function(resolve) {
                                    const fileName = getFileNameFromPath(file.path);
                                    const dirName = getDirNameFromPath(file.path);
                                    const fileType = getFileType(fileName, blob.type);
                                    
                                    const reader = new FileReader();
                                    reader.onload = function() {
                                        // Check if there's a thumbnail for this file and save it
                                        const thumbPath = `${file.path}_thumb.jpg`;
                                        const thumbData = mediaStore.get(thumbPath);
                                        
                                        // Prepare media object
                                        const mediaData = {
                                            data: reader.result,
                                            type: fileType,
                                            name: fileName,
                                            path: file.path,
                                            directory: dirName
                                        };
                                        
                                        // Add thumbnail if exists
                                        if (thumbData) {
                                            mediaData.thumbnail_data = thumbData.data;
                                        }
                                        
                                        // Save directory and full filename for better identification
                                        mediaStore.set(fileName, mediaData);
                                        
                                        // Also save with full path as key
                                        mediaStore.set(file.path, mediaData);
                                        
                                        mediaCount++;
                                        if (mediaCount % 10 === 0) {
                                            updateLoaderText(`Processing media files... ${mediaCount}/${regularMediaFiles.length + specialMediaFiles.length}`);
                                        }
                                        resolve();
                                    };
                                    reader.readAsDataURL(blob);
                                });
                            }).catch(error => {
                                console.error(`Error processing file ${file.path}:`, error);
                                return Promise.resolve(); // Continue even if error
                            });
                        });

                        await Promise.all(mediaPromises);
                        console.log('Media store:', Array.from(mediaStore.keys()));
                        updateChatView();
                        showStatusMessage(`Chat loaded successfully with ${mediaCount + specialMediaFiles.length} media files`, 'success');
                        hideLoader();
                        
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                        showStatusMessage('Error processing JSON file', 'error');
                        hideLoader();
                    }
                } catch (error) {
                    console.error('Error loading zip file:', error);
                    showStatusMessage('Error opening archive file', 'error');
                    hideLoader();
                }
            };
            
            reader.onerror = function() {
                console.error('Error reading zip file');
                showStatusMessage('Error reading archive file', 'error');
                hideLoader();
            };
            
            reader.readAsArrayBuffer(file);
        }

        // Extract filename from path
        function getFileNameFromPath(path) {
            if (path.includes('/')) {
                // If there's a directory path, take only the last part
                const parts = path.split('/');
                return parts[parts.length - 1];
            }
            return path;
        }
        
        // Extract directory name from path
        function getDirNameFromPath(path) {
            if (path.includes('/')) {
                const parts = path.split('/');
                if (parts.length > 1) {
                    return parts[parts.length - 2]; // Last directory
                }
            }
            return '';
        }
        
        // Check if file is a media file
        function isMediaFile(fileName) {
            const mediaExtensions = [
                '.jpg', '.jpeg', '.png', '.gif', '.webp', '.tgs',  // Images and stickers
                '.mp4', '.avi', '.mov', '.webm',                   // Video
                '.mp3', '.ogg', '.wav', '.m4a', '.opus',           // Audio
                '.pdf', '.doc', '.docx',                           // Documents
                '.tgz', '.zip', '.rar'                             // Archives
            ];
            
            const lowerName = fileName.toLowerCase();
            
            // Telegram filename patterns
            const telegramFilePatterns = [
                'photo_', 'video_', 'audio_', 'voice_', 
                'sticker_', 'animation_', 'document_',
                'round_video_', 'profile_photo_'
            ];
            
            // Check file extensions
            const hasMediaExtension = mediaExtensions.some(ext => lowerName.endsWith(ext));
            
            // Check Telegram file name patterns
            const hasTelegramPattern = telegramFilePatterns.some(pattern => lowerName.includes(pattern));
            
            // Check if it's a thumbnail
            const isThumbnail = lowerName.includes('_thumb') || lowerName.includes('_thumbnail');
            
            return hasMediaExtension || hasTelegramPattern || isThumbnail;
        }
        
        // Identify file type
        function getFileType(fileName, fallbackType) {
            const lowerName = typeof fileName === 'string' ? fileName.toLowerCase() : '';
            
            // Match by extension for better type detection
            if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg') || lowerName.includes('photo_')) {
                return 'image/jpeg';
            }
            if (lowerName.endsWith('.png')) {
                return 'image/png';
            }
            if (lowerName.endsWith('.heic') || lowerName.endsWith('.HEIC')) {
                return 'image/heic'; // HEIC format
            }
            if (lowerName.endsWith('.mp4') || lowerName.includes('video_')) {
                return 'video/mp4';
            }
            if (lowerName.endsWith('.mov') || lowerName.endsWith('.MOV')) {
                return 'video/quicktime'; // MOV format
            }
            if (lowerName.includes('round_video_')) {
                return 'video/mp4';
            }
            if (lowerName.endsWith('.ogg') || lowerName.endsWith('.opus') || lowerName.includes('voice_')) {
                return 'audio/ogg';
            }
            if (lowerName.endsWith('.mp3') || lowerName.includes('audio_')) {
                return 'audio/mp3';
            }
            if (lowerName.endsWith('.webp') || lowerName.includes('sticker_')) {
                return 'image/webp';
            }
            if (lowerName.endsWith('.tgs')) {
                return 'application/x-tgsticker';
            }
            if (lowerName.endsWith('.gif') || lowerName.includes('animation_')) {
                return 'image/gif';
            }
            
            // Add more file types as needed
            if (lowerName.endsWith('.pdf')) return 'application/pdf';
            if (lowerName.endsWith('.doc') || lowerName.endsWith('.docx')) return 'application/msword';
            if (lowerName.endsWith('.wav')) return 'audio/wav';
            if (lowerName.endsWith('.m4a')) return 'audio/m4a';
            
            // Return fallback type if provided
            return fallbackType || 'application/octet-stream';
        }

        // ===================================================
        // ================ Telegram Export Processing ================
        // ===================================================
        
        // Function to process Telegram export
        function processTelegramExport(data) {
            // Clear previous participants
            participants.clear();
            
            // Process chat info
            if (data.name) {
                chatData.name = data.name;
            } else if (data.chat && data.chat.name) {
                chatData.name = data.chat.name;
            } else {
                chatData.name = 'Telegram Chat';
            }
            
            if (data.type) {
                chatData.type = data.type;
            } else if (data.chat && data.chat.type) {
                chatData.type = data.chat.type;
            } else {
                chatData.type = 'private';
            }
            
            chatData.about = data.about || (data.chat && data.chat.about) || '';
            
            // Identify current user
            if (data.personal_information) {
                currentUser.id = data.personal_information.user_id || null;
                currentUser.name = data.personal_information.first_name || '';
                if (data.personal_information.last_name) {
                    currentUser.name += ' ' + data.personal_information.last_name;
                }
                currentUser.username = data.personal_information.username || '';
            }
            
            // Process participants/contacts list
            const usersData = data.users || (data.chat && data.chat.users) || [];
            
            usersData.forEach(user => {
                let userName = user.first_name || '';
                if (user.last_name) {
                    userName += ' ' + user.last_name;
                }
                
                // If no name, use username
                if (!userName && user.username) {
                    userName = user.username;
                }
                
                // If still no name, use ID
                if (!userName) {
                    userName = `User ${user.id}`;
                }
                
                // Add user to participants map
                addParticipant(user.id, userName, user.username);
            });
            
            // Process messages
            chatData.messages = [];
            
            const messagesData = data.messages || (data.chat && data.chat.messages) || [];
            
            messagesData.forEach(msg => {
                // Handle different message types
                if (msg.type === 'service' || msg.action) {
                    // Service message (join/leave/rename etc.)
                    chatData.messages.push({
                        id: msg.id,
                        type: 'service',
                        date: formatDate(msg.date),
                        text: msg.text || msg.action || '',
                        action: msg.action || ''
                    });
                } else {
                    // Regular message
                    let isOutgoing = false;
                    let senderId = msg.from_id;
                    
                    // Check if message is outgoing (sent by current user)
                    if (msg.from_id === currentUser.id || msg.out || msg.outgoing) {
                        isOutgoing = true;
                    }
                    
                    // In some formats, sender ID is under 'from'
                    if (!senderId && msg.from) {
                        if (typeof msg.from === 'object' && msg.from.id) {
                            senderId = msg.from.id;
                        } else if (typeof msg.from === 'string' || typeof msg.from === 'number') {
                            senderId = msg.from;
                        }
                    }
                    
                    // Get sender name
                    let senderName = msg.from_name || '';
                    
                    // If no explicit name, try to find sender in participants list
                    if (!senderName && senderId && participants.has(senderId)) {
                        senderName = participants.get(senderId).name;
                    } else if (!senderName && msg.from) {
                        // If there's a 'from' object, take name from it
                        if (typeof msg.from === 'object') {
                            senderName = msg.from.first_name || '';
                            if (msg.from.last_name) {
                                senderName += ' ' + msg.from.last_name;
                            }
                        } else {
                            senderName = String(msg.from);
                        }
                    }
                    
                    // If still no sender name, set as unknown
                    if (!senderName) {
                        senderName = 'Unknown';
                    }
                    
                    // Check if sender already exists in participants, if not - add them
                    if (senderId && !participants.has(senderId)) {
                        addParticipant(senderId, senderName, null);
                    }
                    
                    // Prepare message
                    const messageText = msg.text || '';
                    
                    // Find matching media file
                    let mediaType = null;
                    let mediaFile = null;
                    let mediaFileId = null;
                    let mediaDuration = null;
                    let fileName = null;
                    
                    // Check all possible media types
                    if (msg.photo) {
                        mediaType = 'photo';
                        mediaFile = msg.photo;
                        mediaFileId = getMediaId(msg.photo, 'photo');
                    } else if (msg.video) {
                        mediaType = 'video';
                        mediaFile = msg.video;
                        mediaFileId = getMediaId(msg.video, 'video');
                        mediaDuration = msg.video.duration;
                    } else if (msg.file) {
                        // Handle files based on media_type
                        if (msg.media_type === 'video_file' || msg.mime_type?.includes('video')) {
                            mediaType = 'video';
                            fileName = msg.file_name;
                        } else if (msg.media_type === 'voice_message') {
                            mediaType = 'voice';
                            fileName = msg.file_name;
                        } else if (msg.media_type === 'video_message') {
                            mediaType = 'video_note';
                            fileName = msg.file_name;
                        } else if (msg.media_type === 'sticker') {
                            mediaType = 'sticker';
                            fileName = msg.file_name;
                        } else if (msg.media_type === 'animation') {
                            mediaType = 'animation';
                            fileName = msg.file_name;
                        } else {
                            mediaType = 'document';
                            fileName = msg.file_name;
                        }
                        
                        mediaFile = msg.file;
                        mediaFileId = getFileNameFromPath(msg.file);
                        mediaDuration = msg.duration_seconds;
                    } else if (msg.voice) {
                        mediaType = 'voice';
                        mediaFile = msg.voice;
                        mediaFileId = getMediaId(msg.voice, 'voice');
                        mediaDuration = msg.voice.duration;
                    } else if (msg.audio) {
                        mediaType = 'audio';
                        mediaFile = msg.audio;
                        mediaFileId = getMediaId(msg.audio, 'audio');
                        mediaDuration = msg.audio.duration;
                    } else if (msg.sticker) {
                        mediaType = 'sticker';
                        mediaFile = msg.sticker;
                        mediaFileId = getMediaId(msg.sticker, 'sticker');
                    } else if (msg.animation) {
                        mediaType = 'animation';
                        mediaFile = msg.animation;
                        mediaFileId = getMediaId(msg.animation, 'animation');
                    } else if (msg.document || msg.file) {
                        mediaType = 'document';
                        mediaFile = msg.document || msg.file;
                        mediaFileId = getMediaId(msg.document || msg.file, 'document');
                        fileName = msg.file_name;
                    } else if (msg.location) {
                        mediaType = 'location';
                        mediaFile = null;
                        mediaFileId = null;
                    } else if (msg.poll) {
                        mediaType = 'poll';
                        mediaFile = null;
                        mediaFileId = null;
                    } else if (msg.video_note) {
                        mediaType = 'video_note';
                        mediaFile = msg.video_note;
                        mediaFileId = getMediaId(msg.video_note, 'round_video');
                        mediaDuration = msg.video_note.duration;
                    }
                    
                    // Create new message object
                    const message = {
                        id: msg.id,
                        type: 'message',
                        date: formatDate(msg.date),
                        time: formatTime(msg.date),
                        timestamp: new Date(msg.date).getTime(),
                        sender: senderName,
                        senderId: senderId,
                        text: messageText,
                        isOutgoing: isOutgoing,
                        edited: msg.edited || false,
                        forwarded: msg.forwarded_from ? true : false,
                        forwarded_from: msg.forwarded_from || null,
                        reply_to: msg.reply_to_message_id || null,
                        mediaType: mediaType,
                        mediaFile: mediaFile,
                        mediaFileId: mediaFileId,
                        mediaDuration: mediaDuration,
                        file: msg.file,                     // Save original file path
                        file_name: fileName || msg.file_name,  // Save filename
                        sticker_emoji: msg.sticker_emoji,   // Sticker emoji
                        mime_type: msg.mime_type,           // MIME type
                        media_type: msg.media_type,         // Media type as defined by Telegram
                        views: msg.views || 0,
                        reactions: msg.reactions || [],
                        thumbnail: msg.thumbnail         // Path to thumbnail
                    };

                    // Handle contact
                    if (msg.contact_information) {
                        message.mediaType = 'contact';
                        message.contact = msg.contact_information;
                    }

                    // Handle location
                    if (msg.location_information) {
                        message.mediaType = 'location';
                        message.location = msg.location_information;
                    }

                    // Additional check for stickers
                    if (message.mediaType === 'sticker' && msg.file && msg.file.endsWith('.tgs')) {
                        message.is_animated_sticker = true;
                    }

                    // Special check for HEIC files
                    if (message.file_name && message.file_name.toLowerCase().endsWith('.heic')) {
                        message.is_heic = true;
                    }

                    // Special handling for MOV files
                    if (message.file_name && message.file_name.toLowerCase().endsWith('.mov')) {
                        message.mediaType = 'video';
                    }

                    // Add thumbnail info
                    if (msg.thumbnail) {
                        message.thumbnail = msg.thumbnail;
                        message.thumbnail_file_size = msg.thumbnail_file_size;
                    }
                    
                    chatData.messages.push(message);
                }
            });
            
            // Sort messages by date
            chatData.messages.sort((a, b) => {
                if (a.timestamp && b.timestamp) {
                    return a.timestamp - b.timestamp;
                }
                return 0;
            });
            
            // Select a random receiver from participants
            if (participants.size > 0) {
                // Convert map to array and select a random participant
                const participantsArray = Array.from(participants.values());
                const randomParticipant = participantsArray[Math.floor(Math.random() * participantsArray.length)];
                currentReceiverId = randomParticipant.id;
                console.log(`Random receiver selected: ${randomParticipant.name} (ID: ${currentReceiverId})`);
            }
        }

        // Function to extract media ID from media object
        function getMediaId(mediaObj, type) {
            if (!mediaObj) return null;
            
            // Try to find media ID in different formats
            if (mediaObj.file_id) {
                return mediaObj.file_id;
            }
            
            if (mediaObj.id) {
                return `${type}_${mediaObj.id}`;
            }
            
            if (mediaObj.file_name) {
                return mediaObj.file_name;
            }
            
            if (mediaObj.file_path) {
                return getFileNameFromPath(mediaObj.file_path);
            }
            
            // If no explicit ID, return null
            return null;
        }
        
        // Format date
        function formatDate(dateString) {
            // Check if it's a valid date
            if (!dateString) return '';
            
            const date = new Date(dateString);
            
            // Check if date is valid
            if (isNaN(date.getTime())) return dateString;
            
            return date.toLocaleDateString('he-IL', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit' 
            });
        }
        
        // Format time
        function formatTime(dateString) {
            // Check if it's a valid date
            if (!dateString) return '';
            
            const date = new Date(dateString);
            
            // Check if date is valid
            if (isNaN(date.getTime())) return '';
            
            return date.toLocaleTimeString('he-IL', { 
                hour: '2-digit',
                minute: '2-digit' 
            });
        }
        
        // Format duration (for videos and voice messages)
        function formatDuration(seconds) {
            if (!seconds || isNaN(seconds)) return '00:00';
            
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // ===================================================
        // ================== Participant Management ==================
        // ===================================================
        
        // Generate random color for each participant
        function generateRandomColor() {
            // Telegram-style colors
            const colors = [
                '#5682a3', '#4fad2d', '#d55555', '#a85e93',
                '#e17076', '#f2a45c', '#7ec4ea', '#65aadd',
                '#9a86bd', '#5fbed5', '#76c84d', '#ff5555',
                '#ffa85c', '#82b1ff', '#0088cc', '#36a3e5',
                '#69b4ff', '#ff708e', '#c67171', '#9b7dd4'
            ];
            
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Add new participant
        function addParticipant(id, name, username) {
            // Ensure ID is a string
            const participantId = String(id);
            
            if (!participants.has(participantId)) {
                participants.set(participantId, {
                    id: participantId,
                    name: name,
                    username: username || '',
                    color: generateRandomColor(),
                    avatar: null
                });
            }
            return participants.get(participantId);
        }
        
        // Set participant as receiver of messages
        function setAsReceiver(id) {
            if (participants.has(id)) {
                currentReceiverId = id;
                updateParticipantsList();
                updateChatView();
                showStatusMessage(`${participants.get(id).name} הוגדר כמקבל ההודעות`, 'success');
            }
        }
        
        // Update participants list in panel
        function updateParticipantsList() {
            const container = document.getElementById('participants-list');
            
            if (participants.size === 0) {
                container.innerHTML = `
                    <div class="no-participants">
                        <p>אין משתתפים להצגה. העלה קובץ שיחה תחילה.</p>
                    </div>
                `;
                return;
            }
            
            let participantsHtml = '';
            
            participants.forEach((participant, id) => {
                const initialLetter = participant.name.charAt(0);
                let avatarContent = '';
                
                if (participant.avatar) {
                    avatarContent = `<img src="${participant.avatar}" alt="${participant.name}">`;
                } else {
                    avatarContent = initialLetter;
                }

                // Add indicator for current receiver and option to set as receiver
                const isReceiver = id === currentReceiverId;
                
                participantsHtml += `
                    <div class="participant-item" data-id="${id}">
                        <div class="participant-avatar" style="background-color: ${participant.color}">
                            ${avatarContent}
                        </div>
                        <div class="participant-info">
                            <div class="participant-name">
                                <span class="participant-color-preview" style="background-color: ${participant.color}"></span>
                                ${participant.name}
                                ${participant.username ? `(@${participant.username})` : ''}
                                ${isReceiver ? '<span style="color: #28a745; margin-right: 5px;"><i class="fas fa-user-check"></i> מקבל</span>' : ''}
                            </div>
                            <div class="color-picker-container">
                                <span class="color-picker-label">צבע:</span>
                                <input type="color" class="participant-color" value="${participant.color}" 
                                    data-id="${id}" onchange="updateParticipantColor('${id}', this.value)">
                            </div>
                        </div>
                        <div class="participant-actions">
                            <button class="participant-upload" 
                                onclick="setAsReceiver('${id}')" 
                                title="הגדר כמקבל" 
                                ${isReceiver ? 'disabled' : ''}>
                                <i class="fas fa-user-check"></i>
                            </button>
                            <label class="participant-upload">
                                <i class="fas fa-image"></i>
                                <input type="file" accept="image/*" style="display: none;" 
                                    data-id="${id}" onchange="handleParticipantAvatarUpload(event, '${id}')">
                            </label>
                            <button class="remove-image-btn" 
                                onclick="removeParticipantAvatar('${id}')" 
                                style="display: ${participant.avatar ? 'inline-block' : 'none'};">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = participantsHtml;
        }
        
        // Update participant color
        function updateParticipantColor(id, color) {
            if (participants.has(id)) {
                participants.get(id).color = color;
                updateParticipantsList();
                updateChatView();
            }
        }
        
        // Handle participant avatar upload
        function handleParticipantAvatarUpload(event, id) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                if (participants.has(id)) {
                    participants.get(id).avatar = e.target.result;
                    updateParticipantsList();
                    updateChatView();
                }
            };
            
            reader.readAsDataURL(file);
        }
        
        // Remove participant avatar
        function removeParticipantAvatar(id) {
            if (participants.has(id)) {
                participants.get(id).avatar = null;
                updateParticipantsList();
                updateChatView();
            }
        }
        
        // Open participants panel
        function openParticipantsPanel() {
            updateParticipantsList();
            document.getElementById('participants-panel').style.display = 'flex';
        }
        
        // Close participants panel
        function closeParticipantsPanel() {
            document.getElementById('participants-panel').style.display = 'none';
        }

        // ===================================================
        // ================ Appearance Settings ================
        // ===================================================
        
        // Handle profile image upload
        function handleProfileImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                appSettings.profileImage = e.target.result;
                updateProfilePreview();
                updateChatView();
                document.getElementById('remove-profile-image').style.display = 'inline-block';
            };
            reader.readAsDataURL(file);
        }
        
        // Handle background image upload
        function handleBackgroundImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                appSettings.backgroundImage = e.target.result;
                updateBackgroundPreview();
                updateChatView();
                document.getElementById('remove-background-image').style.display = 'inline-block';
            };
            reader.readAsDataURL(file);
        }
        
        // Update profile image preview
        function updateProfilePreview() {
            const preview = document.getElementById('profile-preview');
            const initial = document.getElementById('profile-initial');
            
            if (appSettings.profileImage) {
                preview.innerHTML = `<img src="${appSettings.profileImage}" alt="Profile image">`;
            } else {
                preview.innerHTML = '';
                initial.textContent = chatData.name ? chatData.name.charAt(0) : '?';
                preview.appendChild(initial);
            }
        }
        
        // Update background image preview
        function updateBackgroundPreview() {
            const preview = document.getElementById('background-preview');
            
            if (appSettings.backgroundImage) {
                preview.style.backgroundImage = `url(${appSettings.backgroundImage})`;
                preview.style.border = 'none';
            } else {
                preview.style.backgroundImage = 'none';
                preview.style.border = '2px dashed #ddd';
            }
        }
        
        // Remove profile image
        function removeProfileImage() {
            appSettings.profileImage = null;
            document.getElementById('profile-image-input').value = '';
            document.getElementById('remove-profile-image').style.display = 'none';
            updateProfilePreview();
            updateChatView();
        }
        
        // Remove background image
        function removeBackgroundImage() {
            appSettings.backgroundImage = null;
            document.getElementById('background-image-input').value = '';
            document.getElementById('remove-background-image').style.display = 'none';
            updateBackgroundPreview();
            updateChatView();
        }
        
        // Open settings panel
        function openSettingsPanel() {
            // Update previews before opening panel
            updateProfilePreview();
            updateBackgroundPreview();
            
            // Show/hide remove buttons based on state
            document.getElementById('remove-profile-image').style.display = 
                appSettings.profileImage ? 'inline-block' : 'none';
                
            document.getElementById('remove-background-image').style.display = 
                appSettings.backgroundImage ? 'inline-block' : 'none';
            
            // Show panel
            document.getElementById('settings-panel').style.display = 'flex';
        }
        
        // Close settings panel
        function closeSettingsPanel() {
            document.getElementById('settings-panel').style.display = 'none';
        }

        // Toggle dark mode
        function toggleDarkMode() {
            appSettings.darkMode = !appSettings.darkMode;
            
            if (appSettings.darkMode) {
                document.body.classList.add('dark-mode');
                document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-sun"></i>';
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-moon"></i>';
            }
            
            // Save preference to localStorage
            try {
                localStorage.setItem('telegramViewerDarkMode', appSettings.darkMode);
            } catch (e) {
                console.log('Could not save dark mode preference');
            }
        }

        // Load dark mode preference
        function loadDarkModePreference() {
            try {
                const savedDarkMode = localStorage.getItem('telegramViewerDarkMode');
                if (savedDarkMode !== null) {
                    appSettings.darkMode = savedDarkMode === 'true';
                    if (appSettings.darkMode) {
                        document.body.classList.add('dark-mode');
                        document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-sun"></i>';
                    }
                }
            } catch (e) {
                console.log('Could not load dark mode preference');
            }
        }

        function toggleMessageSides() {
            appSettings.reverseMessageSides = !appSettings.reverseMessageSides;
            
            // שמירת ההעדפה בזיכרון המקומי
            try {
                localStorage.setItem('telegramViewerReverseSides', appSettings.reverseMessageSides);
            } catch (e) {
                console.log('Could not save reverse sides preference');
            }
            
            updateChatView();
            showStatusMessage(`צדדי השולחים הוחלפו`, 'success');
        }
        // ===================================================
        // ================ Chat View Update ================
        // ===================================================
        
        function updateChatView() {
    if (chatData.messages.length === 0) return;
    
    const container = document.getElementById('chat-container');
    const firstLetter = chatData.name.charAt(0);
    
    // Create chat template with profile image support
    let avatarContent = '';
    if (appSettings.profileImage) {
        avatarContent = `<img src="${appSettings.profileImage}" alt="תמונת פרופיל">`;
    } else {
        avatarContent = firstLetter;
    }
    
    // Add specific Telegram info
    let chatTypeInfo = '';
    if (chatData.type === 'private') {
        chatTypeInfo = 'שיחה פרטית';
    } else if (chatData.type === 'group') {
        chatTypeInfo = 'קבוצה';
    } else if (chatData.type === 'channel') {
        chatTypeInfo = 'ערוץ';
    } else if (chatData.type === 'supergroup') {
        chatTypeInfo = 'סופר-קבוצה';
    } else {
        chatTypeInfo = `${chatData.messages.length} הודעות`;
    }
    
    container.innerHTML = `
        <div class="chat-header">
            <div class="avatar">${avatarContent}</div>
            <div class="chat-info">
                <h2>${chatData.name}</h2>
                <p>${chatTypeInfo}</p>
            </div>
        </div>
        <div class="chat-body ${appSettings.backgroundImage ? 'has-background' : ''}">
            <div id="messages-container"></div>
        </div>
    `;
    
    // Set background if exists (will override the default background)
    const chatBody = document.querySelector('.chat-body');
    if (appSettings.backgroundImage) {
        chatBody.style.backgroundImage = `url(${appSettings.backgroundImage})`;
    }
    
    const messagesContainer = document.getElementById('messages-container');
    let currentDate = null;
    
    // Create messages
    chatData.messages.forEach(message => {
        // Add date header if date changed
        if (message.date !== currentDate) {
            currentDate = message.date;
            const dateHeader = document.createElement('div');
            dateHeader.className = 'date-header';
            dateHeader.innerHTML = `<span>${currentDate}</span>`;
            messagesContainer.appendChild(dateHeader);
        }
        
        // Handle service message
        if (message.type === 'service') {
            const serviceElement = document.createElement('div');
            serviceElement.className = 'service-message';
            serviceElement.innerHTML = `<span>${message.text}</span>`;
            messagesContainer.appendChild(serviceElement);
            return;
        }
        
        // Check if message belongs to current receiver
        const isReceiverMessage = currentReceiverId && message.senderId === currentReceiverId;
        
        // Create message container - set direction based on receiver ID and reverseMessageSides setting
        const messageElement = document.createElement('div');
        
        // הקטע החשוב - קובע את צד ההודעה לפי ההגדרות
        if (appSettings.reverseMessageSides) {
            // מצב הפוך - המקבל בצד ימין
            messageElement.className = `message ${isReceiverMessage ? 'out' : 'in'}`;
        } else {
            // מצב רגיל - המקבל בצד שמאל
            messageElement.className = `message ${isReceiverMessage ? 'in' : 'out'}`;
        }        
        // Message bubble
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        // Sender name (only for received messages in groups)
        if (chatData.type !== 'private' && !messageElement.classList.contains('out')) {
            const senderElement = document.createElement('div');
            senderElement.className = 'sender';
            
            // Get participant data
            const participant = participants.get(message.senderId);
            if (participant) {
                senderElement.style.color = participant.color;
            }
            
            senderElement.textContent = message.sender;
            bubble.appendChild(senderElement);
        }
        
        // Add forwarded status if exists - הצגה בסגנון טלגרם
        if (message.forwarded && message.forwarded_from) {
            const forwardedElement = document.createElement('div');
            forwardedElement.className = 'message-note message-forwarded';
            forwardedElement.innerHTML = `Forwarded from ${message.forwarded_from}`;
            bubble.appendChild(forwardedElement);
        }
        
        // Add reply if exists
        if (message.reply_to) {
            const replyElement = document.createElement('div');
            replyElement.className = 'reply-to';
            
            // Find original message
            const originalMessage = chatData.messages.find(msg => msg.id === message.reply_to);
            
            if (originalMessage) {
    const replySender = originalMessage.sender || 'Unknown';
    
    let replyContent = originalMessage.text || 
        (originalMessage.mediaType === 'photo' 
            ? `<img src="${findMediaFile(originalMessage).data}" style="max-width: 50px; max-height: 50px; object-fit: cover;">` 
            : `[${originalMessage.mediaType}]`);
    
    replyElement.innerHTML = `
        <div class="reply-sender">${replySender}</div>
        <div class="reply-content">${replyContent}</div>
    `;
            } else {
                replyElement.textContent = 'תגובה להודעה';
            }
            
            bubble.appendChild(replyElement);
        }
        
        // Handle different media types
        if (message.mediaType) {
            const mediaElement = createMediaElement(message);
            if (mediaElement) {
                bubble.appendChild(mediaElement);
            }
        }
        
        // Text message content
        if (message.text) {
            const contentElement = document.createElement('div');
            contentElement.className = 'message-content';
            contentElement.textContent = message.text;
            bubble.appendChild(contentElement);
        }
        
        // Add reactions if exist
        if (message.reactions && message.reactions.length > 0) {
            const reactionsElement = document.createElement('div');
            reactionsElement.className = 'reactions';
            
            message.reactions.forEach(reaction => {
                // Some formats use emoji directly, some use an object
                const emoji = reaction.emoji || (reaction.reaction ? reaction.reaction : '👍');
                const count = reaction.count || 1;
                
                reactionsElement.innerHTML += `
                    <div class="reaction">
                        <span class="emoji">${emoji}</span>
                        <span class="count">${count}</span>
                    </div>
                `;
            });
            
            bubble.appendChild(reactionsElement);
        }
        
        // Add note if message was edited
        if (message.edited) {
            const noteElement = document.createElement('div');
            noteElement.className = 'message-note message-edited';
            noteElement.innerHTML = `<i class="fas fa-edit"></i> נערך`;
            bubble.appendChild(noteElement);
        }
        
        // Views info (for channels)
        if (message.views && message.views > 0 && (chatData.type === 'channel' || chatData.type === 'supergroup')) {
            const viewsElement = document.createElement('span');
            viewsElement.className = 'message-views';
            viewsElement.innerHTML = `<i class="fas fa-eye"></i> ${message.views}`;
            bubble.appendChild(viewsElement);
        }
        
        // Message time
        const timeElement = document.createElement('div');
        timeElement.className = 'message-time';
        timeElement.textContent = message.time;
        bubble.appendChild(timeElement);
        
        // Add to messages container
        messageElement.appendChild(bubble);
        messagesContainer.appendChild(messageElement);
    });
    
    // Scroll to bottom of chat
    chatBody.scrollTop = chatBody.scrollHeight;
    
    // Setup image event listeners
    setupImageEventListeners();
    onChatLoaded();
}        // Create media element based on type
        function createMediaElement(message) {
            if (!message.mediaType) return null;
            
            const mediaContainer = document.createElement('div');
            
            // Load external libraries if needed
            loadExternalLibraries();
            
            // Find matching media file
            const mediaFile = findMediaFile(message);
            
            // Create unique element ID
            const elementId = 'media_' + message.id + '_' + Math.random().toString(36).substr(2, 5);
            mediaContainer.id = elementId;
            
            switch (message.mediaType) {
                case 'photo':
                    mediaContainer.className = 'attachment';
                    if (mediaFile) {
                        // Check if it's a HEIC file that needs special handling
                        if (message.is_heic || (mediaFile.name && mediaFile.name.toLowerCase().endsWith('.heic'))) {
                            // Create download link
                            const downloadInfo = createDownloadableFile(mediaFile, mediaFile.name || 'image.heic');
                            
                            // Check if there's a thumbnail
                            if (message.thumbnail && mediaStore.has(message.thumbnail)) {
                                const thumbFile = mediaStore.get(message.thumbnail);
                                mediaContainer.innerHTML = `
                                    <div class="heic-container">
                                        <img src="${thumbFile.data}" alt="Preview (HEIC)" class="attachment-image">
                                        <div class="heic-info">HEIC file - not directly supported in browser</div>
                                        <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-link">
                                            <i class="fas fa-download"></i> Download original image
                                        </a>
                                    </div>
                                `;
                            } else {
                                mediaContainer.innerHTML = `
                                    <div class="attachment-file">
                                        <i class="fas fa-image"></i>
                                        <span>HEIC image (${mediaFile.name || 'image'})</span>
                                        <a href="${downloadInfo.url}" download="${downloadInfo.fileName}" class="download-link">
                                            <i class="fas fa-download"></i> Download original image
                                        </a>
                                    </div>
                                `;
                            }
                        } else {
                            // Regular image browser can display
                            mediaContainer.innerHTML = `
                                <img src="${mediaFile.data}" alt="Image" 
                                     data-path="${encodeURIComponent(mediaFile.path || '')}" 
                                     class="attachment-image">
                            `;
                        }
                    } else {
                        // If no file but there's a thumbnail, show thumbnail
                        if (message.thumbnail && mediaStore.has(message.thumbnail)) {
                            const thumbFile = mediaStore.get(message.thumbnail);
                            mediaContainer.innerHTML = `
                                <img src="${thumbFile.data}" alt="Preview" 
                                    class="attachment-image">
                                <div class="preview-note">Preview only</div>
                            `;
                        } else {
                            mediaContainer.innerHTML = `
                                <div class="attachment-file">
                                    <i class="fas fa-image"></i>
                                    <span>Image (${message.file_name || 'File not found'})</span>
                                </div>
                            `;
                        }
                    }
                    break;
                    
                case 'video':
                    mediaContainer.className = 'video-container';
                    if (mediaFile) {
                        // Check if it's a MOV file
                        if (message.file_name && message.file_name.toLowerCase().endsWith('.mov')) {
                            // Use special function for MOV files
                            setTimeout(() => handleMovVideo(mediaFile, elementId), 0);
                            mediaContainer.innerHTML = `<div class="loading-media">Loading video...</div>`;
                        } else {
                            // Regular video browser can display
                            let durationText = '';
                            if (message.mediaDuration) {
                                durationText = `<div class="video-duration">${formatDuration(message.mediaDuration)}</div>`;
                            }
                            
                            // Check if there's a thumbnail to use as poster
                            const thumbnailData = mediaFile.thumbnail_data || 
                                (message.thumbnail && mediaStore.has(message.thumbnail) ? 
                                    mediaStore.get(message.thumbnail).data : null);
                            
                            mediaContainer.innerHTML = `
                                <video controls autoplay width="100%" ${thumbnailData ? `poster="${thumbnailData}"` : ''}>
                                    <source src="${mediaFile.data}" type="${mediaFile.type || 'video/mp4'}">
                                    Your browser does not support video display
                                </video>
                                ${durationText}
                            `;
                        }
                    } else {
                        // If no full file, check if there's a thumbnail
                        if (message.thumbnail && mediaStore.has(message.thumbnail)) {
                            const thumbFile = mediaStore.get(message.thumbnail);
                            mediaContainer.innerHTML = `
                                <div class="video-thumbnail">
                                    <img src="${thumbFile.data}" alt="Video preview" class="attachment-image">
                                    <div class="video-play-icon"><i class="fas fa-play-circle"></i></div>
                                    <div class="video-info">Cannot display video: ${message.file_name || message.file || 'Video file'}</div>
                                </div>
                            `;
                        } else {
                            mediaContainer.innerHTML = `
                                <div class="attachment-file">
                                    <i class="fas fa-video"></i>
                                    <span>Video (${message.file_name || message.file || 'File not found'})</span>
                                </div>
                            `;
                        }
                    }
                    break;
                    
                case 'sticker':
                    mediaContainer.className = 'sticker';
                    if (mediaFile) {
                        // Check if it's an animated sticker (TGS)
                        if (message.is_animated_sticker || (mediaFile.name && mediaFile.name.toLowerCase().endsWith('.tgs'))) {
                            // Use special function for animated stickers
                            setTimeout(() => renderTgsSticker(mediaFile, elementId), 0);
                            mediaContainer.innerHTML = `<div class="loading-media">Loading sticker...</div>`;
                        } else {
                            // Regular sticker
                            mediaContainer.innerHTML = `
                                <img src="${mediaFile.data}" alt="Sticker" 
                                     data-path="${encodeURIComponent(mediaFile.path || '')}" 
                                     class="attachment-image">
                            `;
                        }
                    } else {
                        // Check if there's a thumbnail
                        if (message.thumbnail && mediaStore.has(message.thumbnail)) {
                            const thumbFile = mediaStore.get(message.thumbnail);
                            mediaContainer.innerHTML = `
                                <img src="${thumbFile.data}" alt="Sticker (preview)" class="attachment-image">
                            `;
                        } else {
                            const emoji = message.sticker_emoji || '😊';
                            mediaContainer.innerHTML = `
                                <div class="sticker-placeholder">
                                    <span class="sticker-emoji">${emoji}</span>
                                    <span>Sticker</span>
                                </div>
                            `;
                        }
                    }
                    break;
                    
                case 'voice':
                    mediaContainer.className = 'voice-message';
                    if (mediaFile) {
                        const duration = message.mediaDuration ? formatDuration(message.mediaDuration) : '--:--';
                        mediaContainer.innerHTML = `
                            <i class="fas fa-microphone"></i>
                            <audio controls>
                                <source src="${mediaFile.data}" type="${mediaFile.type || 'audio/ogg'}">
                                Your browser does not support audio display
                            </audio>
                            <span class="voice-message-duration">${duration}</span>
                        `;
                    } else {
                        mediaContainer.innerHTML = `
                            <i class="fas fa-microphone"></i>
                            <span>Voice message (${message.file_name || message.file || 'File not found'})</span>
                        `;
                    }
                    break;
                    
                case 'document':
                    mediaContainer.className = 'document-container';
                    if (mediaFile) {
                        // Use function for handling generic files with download option
                        setTimeout(() => handleGenericFile(mediaFile, elementId), 0);
                        mediaContainer.innerHTML = `<div class="loading-media">Loading file...</div>`;
                    } else {
                        let fileName = message.file_name || '';
                        mediaContainer.innerHTML = `
                            <div class="document-icon">
                                <i class="fas fa-file"></i>
                            </div>
                            <div class="document-info">
                                <div class="document-title">${fileName || 'File'}</div>
                                <div class="document-status">(File not found)</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'video_note':
                    mediaContainer.className = 'video-note';
                    if (mediaFile) {
                        mediaContainer.innerHTML = `
                            <video controls autoplay loop>
                                <source src="${mediaFile.data}" type="${mediaFile.type || 'video/mp4'}">
                                Your browser does not support video display
                            </video>
                        `;
                    } else {
                        // Check if there's a thumbnail
                        if (message.thumbnail && mediaStore.has(message.thumbnail)) {
                            const thumbFile = mediaStore.get(message.thumbnail);
                            mediaContainer.innerHTML = `
                                <div class="video-note-thumbnail" style="border-radius: 50%; overflow: hidden;">
                                    <img src="${thumbFile.data}" alt="Round video (preview)" style="width: 150px; height: 150px; object-fit: cover;">
                                </div>
                            `;
                        } else {
                            mediaContainer.innerHTML = `
                                <div class="attachment-file">
                                    <i class="fas fa-circle"></i>
                                    <span>Round video message (${message.file_name || message.file || 'File not found'})</span>
                                </div>
                            `;
                        }
                    }
                    break;
                    
                case 'contact':
                    mediaContainer.className = 'contact-preview';
                    if (message.contact) {
                        const contact = message.contact;
                        const fullName = `${contact.first_name || ''} ${contact.last_name || ''}`.trim();
                        mediaContainer.innerHTML = `
                            <div class="contact-info">
                                <div class="contact-avatar">
                                    <i class="fas fa-user"></i>
                                </div>
                                <div class="contact-details">
                                    <div class="contact-name">${fullName || 'Contact'}</div>
                                    ${contact.phone_number ? `<div class="contact-phone">${contact.phone_number}</div>` : ''}
                                </div>
                            </div>
                        `;
                    } else {
                        mediaContainer.innerHTML = `
                            <div class="contact-info">
                                <i class="fas fa-user"></i>
                                <span>Contact</span>
                            </div>
                        `;
                    }
                    break;
                    
                case 'location':
                    mediaContainer.className = 'location-preview';
                    if (message.location) {
                        const location = message.location;
                        const mapUrl = `https://www.openstreetmap.org/?mlat=${location.latitude}&mlon=${location.longitude}&zoom=15`;
                        
                        mediaContainer.innerHTML = `
                            <div class="location-box">
                                <i class="fas fa-map-marker-alt"></i>
                                <div class="location-info">
                                    <div>Location:</div>
                                    <div class="location-coordinates">${location.latitude}, ${location.longitude}</div>
                                    <a href="${mapUrl}" target="_blank" class="location-link">Open in map</a>
                                </div>
                            </div>
                        `;
                    } else {
                        mediaContainer.innerHTML = `
                            <div class="location-box">
                                <i class="fas fa-map-marker-alt"></i>
                                <span>Location</span>
                            </div>
                        `;
                    }
                    break;
                    
                case 'audio':
                    mediaContainer.className = 'audio-attachment';
                    if (mediaFile) {
                        mediaContainer.innerHTML = `
                            <audio controls>
                                <source src="${mediaFile.data}" type="${mediaFile.type || 'audio/mp3'}">
                                Your browser does not support audio display
                            </audio>
                        `;
                    } else {
                        mediaContainer.innerHTML = `
                            <div class="attachment-file">
                                <i class="fas fa-music"></i>
                                <span>Audio file (${message.file_name || message.file || 'File not found'})</span>
                            </div>
                        `;
                    }
                    break;
                    
                case 'animation':
                    mediaContainer.className = 'attachment';
                    if (mediaFile) {
                        if (mediaFile.type && mediaFile.type.includes('image/gif')) {
                            mediaContainer.innerHTML = `
                                <img src="${mediaFile.data}" alt="Animation" 
                                     data-path="${encodeURIComponent(mediaFile.path || '')}" 
                                     class="attachment-image">
                            `;
                        } else {
                            mediaContainer.innerHTML = `
                                <video autoplay loop muted width="100%">
                                    <source src="${mediaFile.data}" type="${mediaFile.type || 'video/mp4'}">
                                    Your browser does not support animation display
                                </video>
                            `;
                        }
                    } else {
                        mediaContainer.innerHTML = `
                            <div class="attachment-file">
                                <i class="fas fa-film"></i>
                                <span>Animation (${message.file_name || message.file || 'File not found'})</span>
                            </div>
                        `;
                    }
                    break;
                    
                case 'poll':
                    mediaContainer.className = 'poll-container';
                    let pollOptions = '';
                    
                    if (message.poll && message.poll.options) {
                        message.poll.options.forEach(option => {
                            const percentage = message.poll.total_voters > 0 ? 
                                Math.round((option.voters / message.poll.total_voters) * 100) : 0;
                            
                            pollOptions += `
                                <div class="poll-option">
                                    <div class="poll-option-text">${option.text}</div>
                                    <div class="poll-option-votes">${option.voters} (${percentage}%)</div>
                                    <div class="poll-option-bar">
                                        <div class="poll-option-progress" style="width: ${percentage}%"></div>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    mediaContainer.innerHTML = `
                        <div class="poll-question">${message.poll ? message.poll.question : 'Poll'}</div>
                        ${pollOptions}
                        <div class="poll-total">${message.poll ? `Total votes: ${message.poll.total_voters}` : ''}</div>
                    `;
                    break;
                    
                default:
                    return null;
            }
            
            return mediaContainer;
        }

        // Format file size
        function formatFileSize(sizeInBytes) {
            if (!sizeInBytes || isNaN(sizeInBytes)) return '';
            
            const kb = sizeInBytes / 1024;
            if (kb < 1024) {
                return Math.round(kb) + ' KB';
            }
            
            const mb = kb / 1024;
            if (mb < 1024) {
                return mb.toFixed(1) + ' MB';
            }
            
            const gb = mb / 1024;
            return gb.toFixed(2) + ' GB';
        }
        
        // Find media file in store based on message
        function findMediaFile(message) {
            if (!message || !message.mediaType) return null;
            
            // 1. First try direct file path matching if available in the message
            if (message.photo) {
                const photoPath = message.photo;
                for (const [key, value] of mediaStore.entries()) {
                    if (value.path === photoPath || key === getFileNameFromPath(photoPath)) {
                        return value;
                    }
                }
            }
            
            if (message.file) {
                const filePath = message.file;
                for (const [key, value] of mediaStore.entries()) {
                    if (value.path === filePath || key === getFileNameFromPath(filePath)) {
                        return value;
                    }
                }
            }
            
            // 2. Try finding by mediaFileId (if available)
            if (message.mediaFileId) {
                for (const [key, value] of mediaStore.entries()) {
                    if (key === message.mediaFileId || key.includes(message.mediaFileId)) {
                        return value;
                    }
                }
            }
            
            // 3. For specific file types, try pattern matching
            const fileName = message.file_name || '';
            if (fileName) {
                for (const [key, value] of mediaStore.entries()) {
                    if (key === fileName || getFileNameFromPath(value.path) === fileName) {
                        return value;
                    }
                }
            }
            
            // 4. Try file type directory matching
            const mediaDirectories = {
                'photo': ['photos/', 'photo_'],
                'video': ['video_files/', 'videos/', 'video_'],
                'voice': ['voice_messages/', 'voice_'],
                'video_note': ['round_video_messages/', 'round_video_'],
                'sticker': ['stickers/', 'sticker'],
                'animation': ['animations/', 'animation_'],
                'document': ['files/', 'document_']
            };
            
            const filePatterns = mediaDirectories[message.mediaType] || [];
            for (const pattern of filePatterns) {
                for (const [key, value] of mediaStore.entries()) {
                    const path = value.path || key;
                    if (path.includes(pattern)) {
                        if (fileName && path.includes(fileName)) {
                            return value;
                        }
                        
                        // For files with specific formats
                        if (message.mediaType === 'photo' && value.type.includes('image')) {
                            return value;
                        }
                        if (message.mediaType === 'video' && (value.type.includes('video') || path.endsWith('.MOV'))) {
                            return value;
                        }
                        if (message.mediaType === 'voice' && (value.type.includes('audio') || path.endsWith('.ogg'))) {
                            return value;
                        }
                        if (message.mediaType === 'video_note' && path.includes('round_video')) {
                            return value;
                        }
                    }
                }
            }
            
            // 5. Check based on file extension for common formats
            const extensionMap = {
                'photo': ['.jpg', '.jpeg', '.png', '.heic', '.HEIC'],
                'video': ['.mp4', '.mov', '.MOV', '.avi'],
                'voice': ['.ogg', '.mp3', '.wav'],
                'video_note': ['.mp4', '.mov'],
                'sticker': ['.webp', '.tgs'],
                'animation': ['.gif', '.mp4'],
                'document': ['.pdf', '.doc', '.docx', '.txt']
            };
            
            const extensions = extensionMap[message.mediaType] || [];
            for (const ext of extensions) {
                for (const [key, value] of mediaStore.entries()) {
                    const path = value.path || key;
                    if (path.toLowerCase().endsWith(ext.toLowerCase())) {
                        return value;
                    }
                }
            }
            
            // 6. Last resort - just try to match by timestamp if available
            if (message.timestamp) {
                const date = new Date(message.timestamp);
                const formattedDate = date.toISOString().split('T')[0].replace(/-/g, '');
                
                for (const [key, value] of mediaStore.entries()) {
                    const path = value.path || key;
                    if (path.includes(formattedDate)) {
                        // Match media type with file type
                        if ((message.mediaType === 'photo' && value.type.includes('image')) ||
                            (message.mediaType === 'video' && (value.type.includes('video') || path.endsWith('.MOV'))) ||
                            (message.mediaType === 'voice' && (value.type.includes('audio') || path.endsWith('.ogg'))) ||
                            (message.mediaType === 'video_note' && path.includes('round_video'))) {
                            return value;
                        }
                    }
                }

                // 1. Special check for thumbnails
                if (message.thumbnail) {
                    for (const [key, value] of mediaStore.entries()) {
                        if (key === message.thumbnail || value.path === message.thumbnail) {
                            return value;
                        }
                    }
                }

                // 2. Special check for TGS stickers
                if (message.mediaType === 'sticker' && message.file_name && message.file_name.endsWith('.tgs')) {
                    // Check if there's a thumbnail
                    if (message.thumbnail) {
                        for (const [key, value] of mediaStore.entries()) {
                            if (key === message.thumbnail || value.path === message.thumbnail) {
                                return value;
                            }
                        }
                    }
                    
                    // If no thumbnail, look for the TGS file itself
                    for (const [key, value] of mediaStore.entries()) {
                        if (key.endsWith('.tgs') || (value.path && value.path.endsWith('.tgs'))) {
                            return value;
                        }
                    }
                }

                // 3. Specific checks for problematic files
                const problematicFiles = [
                    "IMG_2435.MOV",  // First video
                    "AnimatedSticker.tgs",  // Animated sticker
                    "IMG_6855.HEIC"  // HEIC image
                ];

                if (message.file_name && problematicFiles.includes(message.file_name)) {
                    // Exact filename match
                    for (const [key, value] of mediaStore.entries()) {
                        if (key === message.file_name || 
                            (value.name && value.name === message.file_name) ||
                            (value.path && value.path.includes(message.file_name))) {
                            return value;
                        }
                    }
                    
                    // Full path match
                    if (message.file) {
                        for (const [key, value] of mediaStore.entries()) {
                            if (key === message.file || value.path === message.file) {
                                return value;
                            }
                        }
                    }
                }

                // 4. For video files, also check different extensions
                if (message.mediaType === 'video' && message.file_name) {
                    const fileNameLower = message.file_name.toLowerCase();
                    if (fileNameLower.endsWith('.mov')) {
                        for (const [key, value] of mediaStore.entries()) {
                            const keyLower = key.toLowerCase();
                            const pathLower = value.path ? value.path.toLowerCase() : '';
                            
                            if (keyLower.endsWith('.mov') || pathLower.endsWith('.mov')) {
                                return value;
                            }
                        }
                    }
                }
            }
            
            return null;
        }

        // Function to get appropriate icon for file type
        function getFileIcon(fileTypeOrName) {
            const lowerType = typeof fileTypeOrName === 'string' ? fileTypeOrName.toLowerCase() : '';
            
            if (lowerType.includes('image') || lowerType.endsWith('.jpg') || lowerType.endsWith('.png') || lowerType.endsWith('.jpeg')) {
                return 'fas fa-file-image';
            } else if (lowerType.includes('video') || lowerType.endsWith('.mp4') || lowerType.endsWith('.mov')) {
                return 'fas fa-file-video';
            } else if (lowerType.includes('audio') || lowerType.endsWith('.mp3') || lowerType.endsWith('.opus') || lowerType.endsWith('.ogg')) {
                return 'fas fa-file-audio';
            } else if (lowerType.includes('pdf') || lowerType.endsWith('.pdf')) {
                return 'fas fa-file-pdf';
            } else if (lowerType.includes('word') || lowerType.endsWith('.doc') || lowerType.endsWith('.docx')) {
                return 'fas fa-file-word';
            } else if (lowerType.includes('excel') || lowerType.endsWith('.xls') || lowerType.endsWith('.xlsx')) {
                return 'fas fa-file-excel';
            } else if (lowerType.includes('zip') || lowerType.endsWith('.zip') || lowerType.endsWith('.tgz') || lowerType.endsWith('.rar')) {
                return 'fas fa-file-archive';
            } else if (lowerType.endsWith('.txt')) {
                return 'fas fa-file-alt';
            } else {
                return 'fas fa-file';
            }
        }

        // ===================================================
        // =================== Helper Functions ==================
        // ===================================================

        // Image event listeners
        function setupImageEventListeners() {
            // Remove previous listeners if any
            const oldImages = document.querySelectorAll('.attachment-image');
            oldImages.forEach(img => {
                img.removeEventListener('click', imageClickHandler);
            });
            
            // Add click listener to all images in document
            document.addEventListener('click', imageClickHandler);
        }

        // Handle image click event
        function imageClickHandler(e) {
            const target = e.target;
            
            // Check if click was on an attachment image
            if (target.classList.contains('attachment-image')) {
                e.preventDefault();
                
                // Get path from data attribute
                const path = target.getAttribute('data-path') ? decodeURIComponent(target.getAttribute('data-path')) : '';
                
                // Show image in modal
                showImageInModal(target.src, path);
            }
        }

        // Show image in modal
        function showImageInModal(imageUrl, path) {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-image');
            
            // Ensure URL is valid
            if (!imageUrl) {
                console.error('No valid image URL');
                return;
            }
            
            modalImg.src = imageUrl;
            modal.style.display = 'flex';
        }

        // Close image modal
        function closeModal() {
            document.getElementById('image-modal').style.display = 'none';
        }

        // Clear all
        function clearAll() {
            chatData = {
                name: '',
                type: '',
                messages: [],
                about: ''
            };
            
            mediaStore.clear();
            participants.clear();
            currentReceiverId = null;
            
            document.getElementById('chat-container').innerHTML = `
                <div class="no-chat">
                    <i class="fas fa-paper-plane"></i>
                    <p>אין שיחה להצגה</p>
                    <p>העלה קובץ ZIP של שיחת טלגרם כדי להתחיל</p>
                </div>
            `;
            
            // Clear file fields
            document.getElementById('json-file').value = '';
            document.getElementById('zip-file').value = '';
            
            showStatusMessage('Data cleared successfully', 'success');
        }

        // Show loader
        function showLoader(message) {
            const loader = document.getElementById('loader');
            document.getElementById('loader-text').textContent = message || 'Loading...';
            loader.style.display = 'flex';
        }

        // Update loader text
        function updateLoaderText(message) {
            document.getElementById('loader-text').textContent = message;
        }

        // Hide loader
        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }

        // Show status message
        function showStatusMessage(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = type;
            statusElement.style.display = 'block';
            
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 3000);
        }

        // ===================================================
        // =================== Chat Export ====================
        // ===================================================

        // Unified function for chat export
        function exportChat(format) {
            if (chatData.messages.length === 0) {
                showStatusMessage('No chat to display. Upload a chat file first', 'error');
                return;
            }
            
            exportToHtml();
        }

        // Function to convert data URLs to safer URLs
        function createSafeMediaUrl(mediaData, mediaType) {
            try {
                // Convert data URL to blob
                if (mediaData.startsWith('data:')) {
                    // Extract binary data from data URL
                    const base64Data = mediaData.split(',')[1];
                    const binaryData = atob(base64Data);
                    
                    // Convert to blob
                    const uint8Array = new Uint8Array(binaryData.length);
                    for (let i = 0; i < binaryData.length; i++) {
                        uint8Array[i] = binaryData.charCodeAt(i);
                    }
                    
                    const blob = new Blob([uint8Array], { type: mediaType });
                    return URL.createObjectURL(blob);
                }
                
                // Return original URL if not data URL
                return mediaData;
            } catch (error) {
                console.error('Error creating safe URL for media:', error);
                return mediaData; // Return original URL in case of error
            }
        }

        // Export to HTML
        function exportToHtml() {
            showLoader('Exporting to HTML...');
            
            // Create clean HTML without tag overflow
            const element = document.getElementById('chat-container');
            const style = document.querySelector('style').innerHTML;
            
            // Convert images to blob URLs for HTML export
            const tempContainer = element.cloneNode(true);
            
            // Handle attached images
            const images = tempContainer.querySelectorAll('.attachment img, .sticker img');
            images.forEach(img => {
                if (img.hasAttribute('data-path')) {
                    const path = decodeURIComponent(img.getAttribute('data-path'));
                    img.removeAttribute('data-path');
                    img.setAttribute('onclick', 'openImageModal(this.src)');
                }
            });
            
            // Handle video elements
            const videos = tempContainer.querySelectorAll('video');
            videos.forEach(video => {
                const source = video.querySelector('source');
                if (source && source.src.startsWith('data:')) {
                    const mediaType = source.type || 'video/mp4';
                    source.src = createSafeMediaUrl(source.src, mediaType);
                }
            });
            
            // Handle audio elements
            const audios = tempContainer.querySelectorAll('audio');
            audios.forEach(audio => {
                const source = audio.querySelector('source');
                if (source && source.src.startsWith('data:')) {
                    const mediaType = source.type || 'audio/ogg';
                    source.src = createSafeMediaUrl(source.src, mediaType);
                }
            });
            
            // Handle profile image
            const profileImage = tempContainer.querySelector('.avatar img');
            if (profileImage && appSettings.profileImage) {
                profileImage.src = appSettings.profileImage;
            }
            
            // Handle background image
            const chatBody = tempContainer.querySelector('.chat-body');
            if (chatBody && appSettings.backgroundImage) {
                // Add style directly to element (not CSS)
                chatBody.style.backgroundImage = `url(${appSettings.backgroundImage})`;
            }
            
            // Add all media files as local assets in HTML file
            let mediaAssetsScript = '';
            let mediaCounter = 0;
            
            for (const [filename, mediaFile] of mediaStore.entries()) {
                mediaCounter++;
                mediaAssetsScript += `
                    mediaStore.set('${filename.replace(/'/g, "\\'")}', {
                        data: '${mediaFile.data.replace(/'/g, "\\'")}',
                        type: '${mediaFile.type}',
                        name: '${filename.replace(/'/g, "\\'")}',
                        path: '${(mediaFile.path || '').replace(/'/g, "\\'")}'
                    });
                `;
                
                // Limit script size
                if (mediaCounter % 50 === 0) {
                    mediaAssetsScript += `
                        console.log('Media loading: ${mediaCounter} files');
                    `;
                }
            }
            
            // Add participants info
            let participantsScript = '';
            for (const [id, participant] of participants.entries()) {
                participantsScript += `
                    participants.set('${id}', {
                        id: '${id}',
                        name: '${participant.name.replace(/'/g, "\\'")}',
                        username: '${participant.username || ''}',
                        color: '${participant.color}'
                        ${participant.avatar ? `, avatar: '${participant.avatar.replace(/'/g, "\\'")}'` : ''}
                    });
                `;
            }
            
// בפונקציית exportToHtml, החלף את הקטע שמגדיר את הסקריפט של ההגדרות:

// Add only profile and background image info if exists
let settingsScript = '';
if (appSettings.profileImage) {
    settingsScript += `
        appSettings.profileImage = '${appSettings.profileImage.replace(/'/g, "\\'")}';
    `;
}
if (appSettings.backgroundImage) {
    settingsScript += `
        appSettings.backgroundImage = '${appSettings.backgroundImage.replace(/'/g, "\\'")}';
    `;
}

// Add dark mode and reverse sides settings
settingsScript += `
    appSettings.darkMode = ${appSettings.darkMode};
    if (appSettings.darkMode) {
        document.body.classList.add('dark-mode');
        document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-sun"></i>';
    }
    
    // Set reverse sides preference
    appSettings.reverseMessageSides = ${appSettings.reverseMessageSides};
    
    // Set current receiver ID
    currentReceiverId = '${currentReceiverId || ''}';
`;

// ובמצב ש-htmlTemplate צריך לכלול:
const htmlTemplate = `<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Chat - ${chatData.name}</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>${style}</style>
</head>
<body style="background-color: var(--main-bg-color); margin: 0; padding: 20px;">
    <div class="toolbar">
        <button id="reverse-sides-btn" onclick="toggleMessageSides()">
            <i class="fas fa-exchange-alt"></i>
            החלף צדדים
        </button>
        <button id="mode-toggle-btn" onclick="toggleDarkMode()">
            <i class="fas fa-${appSettings.darkMode ? 'sun' : 'moon'}"></i>
        </button>
    </div>
    
    <div class="container" style="display: flex; justify-content: center;">
        ${tempContainer.outerHTML}
    </div>
    
    <div id="image-modal" class="modal">
        <span class="modal-close">&times;</span>
        <img class="modal-content" id="modal-image">
    </div>

    <script>
    // Media store for displaying images in modal
    const mediaStore = new Map();
    ${mediaAssetsScript}
    
    // Participants info
    const participants = new Map();
    ${participantsScript}
    
    // Appearance settings
    const appSettings = {
        profileImage: null,
        backgroundImage: null,
        darkMode: false,
        reverseMessageSides: true
    };
    ${settingsScript}
    
    // Current receiver ID
    let currentReceiverId = '${currentReceiverId || ''}';
    
    // Open image in modal
    function openImageModal(src) {
        const modal = document.getElementById('image-modal');
        const modalImg = document.getElementById('modal-image');
        modalImg.src = src;
        modal.style.display = 'flex';
    }
    
    // Close modal
    function closeModal() {
        document.getElementById('image-modal').style.display = 'none';
    }
    
    // Toggle dark mode
    function toggleDarkMode() {
        appSettings.darkMode = !appSettings.darkMode;
        
        if (appSettings.darkMode) {
            document.body.classList.add('dark-mode');
            document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-sun"></i>';
        } else {
            document.body.classList.remove('dark-mode');
            document.getElementById('mode-toggle-btn').innerHTML = '<i class="fas fa-moon"></i>';
        }
        
        // Save preference to localStorage
        try {
            localStorage.setItem('telegramViewerDarkMode', appSettings.darkMode);
        } catch (e) {
            console.log('Could not save dark mode preference');
        }
    }
    
    // Toggle message sides
    function toggleMessageSides() {
        appSettings.reverseMessageSides = !appSettings.reverseMessageSides;
        
        // Need to reload the page to apply changes in the exported HTML
        location.reload();
    }
    
    // Event listeners
    document.querySelector('.modal-close').addEventListener('click', closeModal);
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeModal();
        }
    });

    // Add event listeners to all images
    document.querySelectorAll('.attachment img, .sticker img').forEach(img => {
        img.addEventListener('click', function() {
            openImageModal(this.src);
        });
    });
    
    // Make all GIFs autoplay
    document.querySelectorAll('img[src*=".gif"]').forEach(img => {
        // Ensure GIF is loaded and plays
        if (img.complete) {
            // Force reload to start animation
            const src = img.src;
            img.src = '';
            img.src = src;
        } else {
            img.addEventListener('load', function() {
                // GIF will autoplay when loaded
            });
        }
    });
    
    // Ensure all videos autoplay
    document.querySelectorAll('video').forEach(video => {
        video.setAttribute('autoplay', '');
        video.play().catch(e => {
            console.log('Autoplay prevented by browser policy');
        });
    });
</body>
</html>`;            
            // Create download object
            try {
                const blob = new Blob([htmlTemplate], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `telegram-chat-${chatData.name.replace(/[^\w\s]/gi, '')}-${new Date().toISOString().slice(0, 10)}.html`;
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    hideLoader();
                    showStatusMessage('Chat exported to HTML successfully', 'success');
                }, 100);
            } catch (error) {
                console.error('Error exporting to HTML:', error);
                hideLoader();
                showStatusMessage('Error exporting to HTML', 'error');
            }
        }

        // Function to initialize the interface and load libraries
        function initializeChatViewer() {
            // Load external libraries if needed
            loadExternalLibraries();
            
            // Load dark mode preference
            loadDarkModePreference();
            
            // Add event for cleaning up links before window close
            window.addEventListener('beforeunload', function() {
                cleanupDownloadLinks();
            });
            
            // Refresh chat view
            if (chatData && chatData.messages && chatData.messages.length > 0) {
                updateChatView();
            }
            
            console.log('Telegram chat viewer initialized successfully');
        }

        // Run initialization when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeChatViewer();
        });

        // Add lifecycle function to run after chat loaded
        function onChatLoaded() {
            // Clean previous download links
            cleanupDownloadLinks();
            
            // Check if there are messages that need special handling
            if (chatData && chatData.messages) {
                const problematicMessages = chatData.messages.filter(msg => 
                    (msg.mediaType === 'sticker' && msg.is_animated_sticker) ||
                    (msg.mediaType === 'video' && msg.file_name && msg.file_name.toLowerCase().endsWith('.mov')) ||
                    (msg.mediaType === 'document')
                );
                
                if (problematicMessages.length > 0) {
                    console.log(`Found ${problematicMessages.length} messages that need special handling`);
                }
            }
            
            // Make all GIFs autoplay
            document.querySelectorAll('img[src*=".gif"]').forEach(img => {
                // Ensure GIF is loaded and plays
                if (img.complete) {
                    // Force reload to start animation
                    const src = img.src;
                    img.src = '';
                    img.src = src;
                } else {
                    img.addEventListener('load', function() {
                        // GIF will autoplay when loaded
                    });
                }
            });
            
            // Ensure all videos autoplay
            document.querySelectorAll('video').forEach(video => {
                video.setAttribute('autoplay', '');
                video.play().catch(e => {
                    console.log('Autoplay prevented by browser policy');
                });
            });
        }
    </script>
</body>
</html>
